<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    F嘉阳
</title>
<link rel="shortcut icon" href="https://fjiayang.github.io//favicon.ico?v=1575360796156">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://fjiayang.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://fjiayang.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://fjiayang.github.io/">
                <img class="avatar" src="https://fjiayang.github.io//images/avatar.png?v=1575360796156" alt="">
            </a>
            <div class="site-title">
                <h1>
                    F嘉阳
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://fjiayang.github.io//post/leetcode-shua-ti-ji-lu">
                        LeetCode刷题记录
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-12-03</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            第1天 Jewels and Stones （771）


题号771 Jewels and Stones


题目描述：

给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&amp;quot;a&amp;quot;和&amp;quot;A&amp;quot;是不同类型的石头。



解题思路：字符串遍历比对


心得：查看了排名较前的解法，大部分也是暴力比对，少数取巧解法获得更好的时间复杂度



排名最前的解法

第2天 Unique Email Addresse （929）


题号929 Unique Email Addresses


题目描述：

每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。
例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。
除了小写字母，这些电子邮件还可能包含 &#39;.&#39; 或 &#39;+&#39;。
如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（&#39;.&#39;），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，&amp;quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）
如果在本地名称中添加加号（&#39;+&#39;），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）
可以同时使用这两个规则。
给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？
示例：
输入：[&amp;quot;test.email+alex@leetcode.com&amp;quot;,&amp;quot;test.e.mail+bob.cathy@leetcode.com&amp;quot;,&amp;quot;testemail+david@lee.tcode.com&amp;quot;]
输出：2
解释：实际收到邮件的是 &amp;quot;testemail@leetcode.com&amp;quot; 和 &amp;quot;testemail@lee.tcode.com&amp;quot;。

提示：

1 &amp;lt;= emails[i].length &amp;lt;= 100
1 &amp;lt;= emails.length &amp;lt;= 100
每封 emails[i] 都包含有且仅有一个 &#39;@&#39; 字符。




解题思路：字符串替换+去除重复元素


心得体会：网站测试用例不全导致排名较前的解法有问题，并不能完全符合题目要求，自己的代码时间复杂度还是较高



国外Java精简正则表达式解法

第3天 Sort Array By Parity （905）

题号905 Sort Array By Parity
题目描述：给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。
解题思路：双指针
心得体会：经典解法，时间复杂度为O(n)，遍历数组，将偶数从前往后存放，奇数则从后往前存放


第4天 Encode and Decode TinyURL（535）


题号535 Encode and Decode TinyURL


题目描述：

TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk.



解题思路：短网址算法简化版


心得体会：哈希运算后再转16进制即可明显缩短网址长度，题目没有要求生成的长度，故没有实现真正的短网址算法，也有不运算通过集合直接存储返回下标的，目前暂时没有在讨论区看到更好的Java解法



还有更加取巧的解法，直接暴力返回。。然而还显示739 / 739 个通过测试用例。。排名较前的多为该解法

第5天 Subsets（78）

题号78 Subsets
题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
解题思路：深度优先或者广度优先算法
心得体会：思考了一段时间，之后在讨论区看到BFS、DFS解法，最后看到使用排序和递归结合的DFS简洁解法，拓宽了思路


排序和递归结合的DFS解法

第6天 Minimum Add to Make Parentheses Valid（921）


题号921 Minimum Add to Make Parentheses Valid


题目描述：

给定一个由 &#39;(&#39; 和 &#39;)&#39; 括号组成的字符串 S，我们需要添加最少的括号（ &#39;(&#39; 或是 &#39;)&#39;，可以在任何位置），以使得到的括号字符串有效。
从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

它是一个空字符串，或者
它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
它可以被写作 (A)，其中 A 是有效字符串。

给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。



解题思路：栈，遇到左括号则右括号入栈，遇到右括号则弹出栈顶元素并判断其是否为左括号，栈为空或者判断为false都将计数器自增，最终返回栈大小与计数器之和即可


心得体会：按照题目标签选题为栈，故使用了栈来实现，但耗时其实比直接使用左右括号计数器要长



左右括号计数器解法

第7天 Reverse String（344）

题号 344 Reverse String
题目描述：编写一个函数，其作用是将输入的字符串反转过来。
解题思路：双指针
心得体会：简单题，两个指针分别从前往后和从后往前遍历并交换，但从讨论区也看到了更多的思路，例如使用ACII位运算解法等


ACII位运算解法

第8天 Remove Linked List Elements（203）

题号 203 Remove Linked List Elements
题目描述：删除链表中等于给定值 val 的所有节点。
解题思路：

单链表迭代删除元素
带虚拟头结点单链表迭代删除元素
递归实现


心得体会：简单题，使用指针逐个判断下一个元素是否为待删除元素，迭代直至链表尾部。题目虽然难度不大，但可以增强对链表和递归用法的理解。

非虚拟头结点实现

虚拟头结点实现

递归实现

第9天 Valid Parentheses（20）


题号 20 Valid Parentheses


题目描述：

给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。
有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。



解题思路：栈


心得体会：简单题，栈的基础操作，但注意出栈后仍需判断括号是否匹配以及遍历完毕还需判断栈是否为空



第10天 Binary Tree Inorder Traversal（94）


题号 94 Binary Tree Inorder Traversal


题目描述：

给定一个二叉树，返回它的中序 遍历。
示例:
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]




解题思路：考察二叉树中序遍历递归实现和非递归实现


心得体会：简单题，二叉树的基础操作


递归实现

非递归实现

第11天 Search in a Binary Search Tree（700）


题号 700 Search in a Binary Search Tree


题目描述：

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
例如，
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2

你应该返回如下子树:
      2     
     / \   
    1   3

在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。



解题思路：二叉树节点值比对、查找、递归实现


心得体会：简单题，二叉树的查找操作



第12天 Binary Tree Level Order Traversal II（107）


题号 107 Binary Tree Level Order Traversal II


题目描述：

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其自底向上的层次遍历为：
[
  [15,7],
  [9,20],
  [3]
]




解题思路：深度优先遍历、广度优先遍历


心得体会：由于题目要求自底向上层次遍历，反向输出使用栈实现，考虑使用深度优先并结合队列实现，故使用非递归方式，但每层都要组合为一个集合，考虑使用双队列，解题过程中清楚这并不是最优解，后在评论区看到更优解法



评论区赞同数较高的解法

DFS solution:
public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) {
        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; wrapList = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        
        if(root == null) return wrapList;
        
        queue.offer(root);
        while(!queue.isEmpty()){
            // 记录队列中根节点数量
            int levelNum = queue.size();
            List&amp;lt;Integer&amp;gt; subList = new LinkedList&amp;lt;Integer&amp;gt;();
            for(int i=0; i&amp;lt;levelNum; i++) {
                if(queue.peek().left != null) queue.offer(queue.peek().left);
                if(queue.peek().right != null) queue.offer(queue.peek().right);
                subList.add(queue.poll().val);
            }
            wrapList.add(0, subList);
        }
        return wrapList;
    }
}

BFS solution:
public class Solution {
        public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) {
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; wrapList = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
            levelMaker(wrapList, root, 0);
            return wrapList;
        }
        
        public void levelMaker(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, TreeNode root, int level) {
            if(root == null) return;
            if(level &amp;gt;= list.size()) {
                list.add(0, new LinkedList&amp;lt;Integer&amp;gt;());
            }
            levelMaker(list, root.left, level+1);
            levelMaker(list, root.right, level+1);
            list.get(list.size()-level-1).add(root.val);
        }
}


第13天 Binary Tree Preorder Traversal（144）


题号 144 Binary Tree Preorder Traversal


题目描述：

给定一个二叉树，返回它的 前序 遍历。
示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]




解题思路：二叉树先序遍历递归实现、非递归实现


心得体会：简单题，二叉树的基础操作


递归实现

非递归实现

第14天 Binary Tree Postorder Traversal（145）


题号 145 Binary Tree Postorder Traversal


题目描述：

给定一个二叉树，返回它的 后序 遍历。
示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]




解题思路：二叉树递归操作、双栈使用


心得体会：递归实现较为简单，但非递归实现需要对栈有深刻的理解，通过双栈使用让每个节点在第三次遍历时输出


递归实现

非递归实现

第15天 Merge Two Sorted Lists（21）


题号 21 Merge Two Sorted Lists


题目描述：

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4




解题思路：链表插入操作


心得体会：简单题，注意边界值以及可能出现两个链表长度不等的情况



第16天 Remove Nth Node From End of List（19）


题号 19 Remove Nth Node From End of List


题目描述：

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.

说明：
给定的 n 保证是有效的。
进阶：
使用一趟扫描实现



解题思路：第一趟扫描得到链表大小、用链表大小减去n得到节点顺位下标，按链表删除元素操作即可


心得体会：两趟扫描比较容易想到，解题后在讨论区看到评价较高的一趟扫描排序实现


两趟扫描实现

一趟扫描实现

A one pass solution can be done using pointers. Move one pointer fast --&amp;gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node.
Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary.
public ListNode removeNthFromEnd(ListNode head, int n) {
    
    ListNode start = new ListNode(0);
    ListNode slow = start, fast = start;
    slow.next = head;
    
    //Move fast in front so that the gap between slow and fast becomes n
    for(int i=1; i&amp;lt;=n+1; i++)   {
        fast = fast.next;
    }
    //Move fast to the end, maintaining the gap
    while(fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    //Skip the desired node
    slow.next = slow.next.next;
    return start.next;
}


第17天 Unique Morse Code Words（804）


题号 804 Unique Morse Code Words


题目描述：

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: &amp;quot;a&amp;quot; 对应 &amp;quot;.-&amp;quot;, &amp;quot;b&amp;quot; 对应 &amp;quot;-...&amp;quot;, &amp;quot;c&amp;quot; 对应 &amp;quot;-.-.&amp;quot;, 等等。
为了方便，所有26个英文字母对应摩尔斯密码表如下：
[&amp;quot;.-&amp;quot;,&amp;quot;-...&amp;quot;,&amp;quot;-.-.&amp;quot;,&amp;quot;-..&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;..-.&amp;quot;,&amp;quot;--.&amp;quot;,&amp;quot;....&amp;quot;,&amp;quot;..&amp;quot;,&amp;quot;.---&amp;quot;,&amp;quot;-.-&amp;quot;,&amp;quot;.-..&amp;quot;,&amp;quot;--&amp;quot;,&amp;quot;-.&amp;quot;,&amp;quot;---&amp;quot;,&amp;quot;.--.&amp;quot;,&amp;quot;--.-&amp;quot;,&amp;quot;.-.&amp;quot;,&amp;quot;...&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;..-&amp;quot;,&amp;quot;...-&amp;quot;,&amp;quot;.--&amp;quot;,&amp;quot;-..-&amp;quot;,&amp;quot;-.--&amp;quot;,&amp;quot;--..&amp;quot;]

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，&amp;quot;cab&amp;quot; 可以写成 &amp;quot;-.-..--...&amp;quot;，(即 &amp;quot;-.-.&amp;quot; + &amp;quot;-...&amp;quot; + &amp;quot;.-&amp;quot;字符串的结合)。我们将这样一个连接过程称作单词翻译。
返回我们可以获得所有词不同单词翻译的数量。
例如:
输入: words = [&amp;quot;gin&amp;quot;, &amp;quot;zen&amp;quot;, &amp;quot;gig&amp;quot;, &amp;quot;msg&amp;quot;]
输出: 2
解释: 
各单词翻译如下:
&amp;quot;gin&amp;quot; -&amp;gt; &amp;quot;--...-.&amp;quot;
&amp;quot;zen&amp;quot; -&amp;gt; &amp;quot;--...-.&amp;quot;
&amp;quot;gig&amp;quot; -&amp;gt; &amp;quot;--...--.&amp;quot;
&amp;quot;msg&amp;quot; -&amp;gt; &amp;quot;--...--.&amp;quot;

共有 2 种不同翻译, &amp;quot;--...-.&amp;quot; 和 &amp;quot;--...--.&amp;quot;.

注意:

单词列表words 的长度不会超过 100。
每个单词 words[i]的长度范围为 [1, 12]。
每个单词 words[i]只包含小写字母。




解题思路：通过给定的摩斯密码表翻译成字符串再利用Set去重


心得体会：翻译过程注意数组下标从0开始，故原本a对应96则需要-97，同时该问题不存在大写字母，可减少一部分逻辑



第18天 Intersection of Two Arrays（349）


题号 349 Intersection of Two Arrays


题目描述：

给定两个数组，编写一个函数来计算它们的交集。
示例 1:
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]

示例 2:
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

说明:

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。




解题思路：使用集合对数组去重，并遍历另一个数组，遇到相同元素则添加进结果集，同时删除第一个数组集合中的元素，防止下次再次遇到相同的元素


心得体会：最容易想到的方式是对两个数组都进行去重后比较，但通过使用第一个去重集合在第二个数组遍历过程中遇到相同元素时去除该元素的方式，减少对第二个数组的去重操作，提高性能



第19天 Intersection of Two Arrays II（350）


题号 350 Intersection of Two Arrays II


题目描述：

给定两个数组，编写一个函数来计算它们的交集。
示例 1:
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]

示例 2:
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]

说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。

进阶:

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小很多，哪种方法更优？
如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？




解题思路：首先对第一个数组进行词频统计，在对第二个数组遍历过程中遇到相同元素对词频减一并加入结果集，当词频为0则移除元素，由此实现每个元素出现的次数，应与元素在两个数组中出现的次数一致


心得体会：Map作为词频统计的经典用法，但注意当词频为0时需要移除元素，否则词频计数便没有意义



第20天 N-Repeated Element in Size 2N Array（961）


题号 961 N-Repeated Element in Size 2N Array


题目描述：

在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。
返回重复了 N 次的那个元素。
示例 1：
输入：[1,2,3,3]
输出：3

示例 2：
输入：[2,1,2,5,3,2]
输出：2

示例 3：
输入：[5,1,5,2,5,3,5,4]
输出：5

提示：

4 &amp;lt;= A.length &amp;lt;= 10000
0 &amp;lt;= A[i] &amp;lt; 10000
A.length 为偶数




解题思路：Map词频统计用法，一旦某个元素重复了N次则不再继续统计


心得体会：词频统计的经典用法



第21天 Single Number（136）


题号 136 Single Number


题目描述：

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4




解题思路：Map词频统计用法，统计完成后寻找词频为1的即可


心得体会：Map词频统计法比较容易想到，解题后在官方解答区看到两个更灵活的解法，分别通过数学计算和位运算实现，开阔了解题思路


Map词频统计法

数学运算法
原理
2∗(a+b+c)−(a+a+b+b+c)=c2∗(a+b+c)−(a+a+b+b+c)=c
2∗(a+b+c)−(a+a+b+b+c)=c
class Solution {
    public int singleNumber(int[] nums) {
        return (2 * sum(set(nums)) - sum(nums));
    }

    private int[] set(int[] nums) {
        HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for (int num : nums) {
            set.add(num);
        }
        int[] res = new int[set.size()];
        int i = 0;
        for (Integer integer : set) {
            res[i++] = integer;
        }
        return res;
    }

    private int sum(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }
}

位运算法（已知性能最佳解法）
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int i : nums) {
            // 一个数和0异或还是自己，一个数和自己异或是0
            result ^= i;
        }
        return result;
    }
}

第22天 Top K Frequent Elements（347）


题号 347 Top K Frequent Elements


题目描述：

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

示例 2:
输入: nums = [1], k = 1
输出: [1]

说明：

你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。




解题思路：使用优先队列，维护出现频率前 k 高的元素


心得体会：Java内置的优先队列为小根堆，同时支持定义比较器，结合优先队列特性即可解答



第23天 Top K Frequent Words（692）


题号 692 Top K Frequent Words


题目描述：

给一非空的单词列表，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。
示例 1：
输入: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;leetcode&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;coding&amp;quot;], k = 2
输出: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;]
解析: &amp;quot;i&amp;quot; 和 &amp;quot;love&amp;quot; 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 &amp;quot;i&amp;quot; 在 &amp;quot;love&amp;quot; 之前。

示例 2：
输入: [&amp;quot;the&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;sunny&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;sunny&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;is&amp;quot;], k = 4
输出: [&amp;quot;the&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;sunny&amp;quot;, &amp;quot;day&amp;quot;]
解析: &amp;quot;the&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;sunny&amp;quot; 和 &amp;quot;day&amp;quot; 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。

注意：

假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。
输入的单词均由小写字母组成。

扩展练习：

尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。




解题思路：使用优先队列，维护前 k 个出现次数最多的单词，同时维护字典顺序


心得体会：与347题类似，但需要处理单词有相同出现频率，按字母顺序排序的情况，按照Java默认字符串排序方式和频率大小定义比较器即可



第24天 Range Sum Query - Immutable（303）


题号 303 Range Sum Query - Immutable


题目描述：

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。
示例：
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3

说明:

你可以假设数组不可变。
会多次调用 sumRange 方法。




解题思路：典型的线段树应用场景，但该题可以使用数组维护区间总和，对于该题来说时间复杂度更低


心得体会：线段树解法从读题即可想到，而后由于说明为Immutable，故通过维护数组实现时间复杂度更低


数组实现

线段树实现
class NumArray {
    
    private SegmentTree&amp;lt;Integer&amp;gt; tree;

    public NumArray(int[] nums) {
        Integer[] list = new Integer[nums.length];
            for (int i = 0; i &amp;lt; nums.length; i++) {
                list[i] = nums[i];
            }
            tree = new SegmentTree&amp;lt;&amp;gt;(list,(a, b) -&amp;gt; a+b);
    }
    
    public int sumRange(int i, int j) {
        return tree.query(i,j);
    }
    
    class SegmentTree&amp;lt;E&amp;gt; {

    private E[] data;
    private E[] tree;
    private Merger&amp;lt;E&amp;gt; merger;

    public SegmentTree(E[] arr, Merger&amp;lt;E&amp;gt; merger) {
        this.merger = merger;
        this.data = (E[]) new Object[arr.length];
        // 拷贝副本
        for (int i = 0; i &amp;lt; arr.length; i++) {
            data[i] = arr[i];
        }
        // 创建线段树存储空间，4倍空间可以存储最坏情况下的线段树
        this.tree = (E[]) new Object[4 * arr.length];
        // 创建线段树
        buildSegmentTree(0, 0, data.length - 1);
    }

    /**
     * 在treeIndex的位置创建表示区间[l...r]的线段树
     *
     * @param treeIndex
     * @param left
     * @param right
     */
    private void buildSegmentTree(int treeIndex, int left, int right) {
        if (data.length==0){
            return;
        }
        // 递归终止条件为叶子节点
        if (left == right) {
            tree[treeIndex] = data[left];
            return;
        }
        // 左子树索引
        int leftIndex = leftChild(treeIndex);
        // 右子树索引
        int rightIndex = rightChild(treeIndex);
        // 等价于 (left + right)/2
        int mid = left + (right - left) / 2;
        buildSegmentTree(leftIndex, left, mid);
        buildSegmentTree(rightIndex, mid + 1, right);
        // 线段值由业务情况决定
        tree[treeIndex] = merger.merge(tree[leftIndex], tree[rightIndex]);
    }

    public E query(int queryL, int queryR) {
        if (queryL &amp;lt; 0 || queryL &amp;gt;= data.length ||
                queryR &amp;lt; 0 || queryR &amp;gt;= data.length || queryL &amp;gt; queryR) {
            throw new IllegalArgumentException(&amp;quot;Index is illegal.&amp;quot;);
        }
        return query(0, 0, data.length - 1, queryL, queryR);
    }

    private E query(int treeIndex, int left, int right, int queryL, int queryR) {
        // 查询区间与线段树区间相等则直接返回
        if (left == queryL &amp;amp;&amp;amp; right == queryR) {
            return tree[treeIndex];
        }
        int leftIndex = leftChild(treeIndex);
        int rightIndex = rightChild(treeIndex);
        int mid = left + (right - left) / 2;
        // 若全在左子树
        if (queryR &amp;lt;= mid) {
            return query(leftIndex, left, mid, queryL, queryR);
        } else if (queryL &amp;gt;= mid + 1) {
            // 全在右子树
            return query(rightIndex, mid + 1, right, queryL, queryR);
        }
        // 分散在左右子树
        E leftResult = query(leftIndex, left, mid, queryL, mid);
        E rightResult = query(rightIndex, mid + 1, right, mid + 1, queryR);
        return merger.merge(leftResult, rightResult);
    }

    public int getSize() {
        return data.length;
    }

    public E get(int index) {
        isLegal(index);
        return data[index];
    }

    private void isLegal(int index) {
        if (index &amp;lt; 0 || index &amp;gt; data.length - 1) {
            throw new IllegalArgumentException(&amp;quot;index out of bound&amp;quot;);
        }
    }

    /**
     * 返回平衡二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
     *
     * @param index
     * @return
     */
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    /**
     * 返回平衡二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
     *
     * @param index
     * @return
     */
    private int rightChild(int index) {
        return index * 2 + 2;
    }}
    
    @FunctionalInterface
    public interface Merger&amp;lt;E&amp;gt; {
        /**
         * 合并a、b两个对象
         *
         * @param a
         * @param b
         * @return
         */
        E merge(E a, E b);
    }
}

性能差异



解决方式
耗时
内存




数组
52 ms
41.2 MB


线段树
59 ms
42.2 MB



第25天 Range Sum Query - Mutable（307）


题号 307 Range Sum Query - Mutable


题目描述：

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。
update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。
示例:
Given nums = [1, 3, 5]

sumRange(0, 2) -&amp;gt; 9
update(1, 2)
sumRange(0, 2) -&amp;gt; 8

说明:

数组仅可以在 update 函数下进行修改。
你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。




解题思路：使用线段树或者数组动态维护区间总和


心得体会：与303题类似，也是线段树的典型应用场景，但此时数组为Mutable，虽然也可以通过数组维护区间总和，但更新时需要同时维护多个数值，此时的效率不如线段树


线段树实现
class NumArray {

    private SegmentTree&amp;lt;Integer&amp;gt; tree;

        public NumArray(int[] nums) {
            Integer[] arr = new Integer[nums.length];
            for (int i = 0; i &amp;lt; nums.length; i++) {
                arr[i] = nums[i];
            }
            tree = new SegmentTree&amp;lt;&amp;gt;(arr,(a, b) -&amp;gt; a+b);
        }

        public void update(int i, int val) {
            tree.set(i,val);
        }

        public int sumRange(int i, int j) {
            return tree.query(i,j);
        }
    
    class SegmentTree&amp;lt;E&amp;gt; {

    private E[] data;
    private E[] tree;
    private Merger&amp;lt;E&amp;gt; merger;

    public SegmentTree(E[] arr, Merger&amp;lt;E&amp;gt; merger) {
        this.merger = merger;
        this.data = (E[]) new Object[arr.length];
        // 拷贝副本
        for (int i = 0; i &amp;lt; arr.length; i++) {
            data[i] = arr[i];
        }
        // 创建线段树存储空间，4倍空间可以存储最坏情况下的线段树
        this.tree = (E[]) new Object[4 * arr.length];
        // 创建线段树
        buildSegmentTree(0, 0, data.length - 1);
    }

    /**
     * 在treeIndex的位置创建表示区间[l...r]的线段树
     *
     * @param treeIndex
     * @param left
     * @param right
     */
    private void buildSegmentTree(int treeIndex, int left, int right) {
        if (data.length==0){
            return;
        }
        // 递归终止条件为叶子节点
        if (left == right) {
            tree[treeIndex] = data[left];
            return;
        }
        // 左子树索引
        int leftIndex = leftChild(treeIndex);
        // 右子树索引
        int rightIndex = rightChild(treeIndex);
        // 等价于 (left + right)/2
        int mid = left + (right - left) / 2;
        buildSegmentTree(leftIndex, left, mid);
        buildSegmentTree(rightIndex, mid + 1, right);
        // 线段值由业务情况决定
        tree[treeIndex] = merger.merge(tree[leftIndex], tree[rightIndex]);
    }

    public E query(int queryL, int queryR) {
        if (queryL &amp;lt; 0 || queryL &amp;gt;= data.length ||
                queryR &amp;lt; 0 || queryR &amp;gt;= data.length || queryL &amp;gt; queryR) {
            throw new IllegalArgumentException(&amp;quot;Index is illegal.&amp;quot;);
        }
        return query(0, 0, data.length - 1, queryL, queryR);
    }

    /**
     * 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值
     *
     * @param treeIndex
     * @param left
     * @param right
     * @param queryL
     * @param queryR
     * @return
     */
    private E query(int treeIndex, int left, int right, int queryL, int queryR) {
        // 查询区间与线段树区间相等则直接返回
        if (left == queryL &amp;amp;&amp;amp; right == queryR) {
            return tree[treeIndex];
        }
        int leftIndex = leftChild(treeIndex);
        int rightIndex = rightChild(treeIndex);
        int mid = left + (right - left) / 2;
        // 若全在左子树
        if (queryR &amp;lt;= mid) {
            return query(leftIndex, left, mid, queryL, queryR);
        } else if (queryL &amp;gt;= mid + 1) {
            // 全在右子树
            return query(rightIndex, mid + 1, right, queryL, queryR);
        }
        // 分散在左右子树
        E leftResult = query(leftIndex, left, mid, queryL, mid);
        E rightResult = query(rightIndex, mid + 1, right, mid + 1, queryR);
        return merger.merge(leftResult, rightResult);
    }

    /**
     * 将index位置的值，更新为e
     *
     * @param index
     * @param e
     */
    public void set(int index,E e){
        if (data.length==0){
            return;
        }
        isLegal(index);
        data[index] = e;
        set(0,0,data.length-1,index,e);
    }

    /**
     * 在以treeIndex为根的线段树中更新index的值为e
     *
     * @param treeIndex
     * @param left
     * @param right
     * @param index
     * @param e
     */
    private void set(int treeIndex,int left,int right,int index,E e){
        if (left == right){
            // 更新叶子结点
            tree[treeIndex] = e;
            return;
        }

        int mid = left+(right-left)/2;
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);

        if (index&amp;lt;=mid){
            set(leftTreeIndex,left,mid,index,e);
        }else {
            set(rightTreeIndex,mid+1,right,index,e);
        }
        // 更新线段树节点值
        tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);
    }

    public int getSize() {
        return data.length;
    }

    public E get(int index) {
        isLegal(index);
        return data[index];
    }

    private void isLegal(int index) {
        if (index &amp;lt; 0 || index &amp;gt; data.length - 1) {
            throw new IllegalArgumentException(&amp;quot;index out of bound&amp;quot;);
        }
    }

    /**
     * 返回平衡二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
     *
     * @param index
     * @return
     */
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    /**
     * 返回平衡二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
     *
     * @param index
     * @return
     */
    private int rightChild(int index) {
        return index * 2 + 2;
    }}
    
    @FunctionalInterface
public interface Merger&amp;lt;E&amp;gt; {
    /**
     * 合并a、b两个对象
     *
     * @param a
     * @param b
     * @return
     */
    E merge(E a, E b);
}
    
    
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */

数组实现
class NumArray {

    int[] nums;
        int[] origin;

        public NumArray(int[] nums) {
            origin = new int[nums.length];
            if (nums.length&amp;gt;0){
                origin[0] = nums[0];
            }
            // 第i个位置存储索引[0..i]的和，最后一个位置则为整个数组的和
            for (int i = 1; i &amp;lt; nums.length; i++) {
                origin[i] = nums[i];
                nums[i] += nums[i - 1];
            }

            this.nums = nums;
        }

        public void update(int i, int val) {
            // 更新位置之后的值均要变化
            int oldVal = origin[i];
            int diff = val - oldVal;
            for (int j = i ; j &amp;lt; nums.length; j++) {
                nums[j] += diff;
            }
            origin[i] = val;
        }

        public int sumRange(int i, int j) {
            if (i == 0) {
                return nums[j];
            }
            // 计算区间和
            return nums[j] - nums[i - 1];
        }
}

性能差异



解决方式
耗时
内存




线段树
60 ms
47.3 MB


数组
199 ms
49.3 MB



第26天 Implement Trie (Prefix Tree)（208）


题号 208 Implement Trie (Prefix Tree)


题目描述：

实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
示例:
Trie trie = new Trie();

trie.insert(&amp;quot;apple&amp;quot;);
trie.search(&amp;quot;apple&amp;quot;);   // 返回 true
trie.search(&amp;quot;app&amp;quot;);     // 返回 false
trie.startsWith(&amp;quot;app&amp;quot;); // 返回 true
trie.insert(&amp;quot;app&amp;quot;);   
trie.search(&amp;quot;app&amp;quot;);     // 返回 true

说明:

你可以假设所有的输入都是由小写字母 a-z 构成的。
保证所有输入均为非空字符串。




解题思路：字典树（前缀树）实现


心得体会：字典树（前缀树）实现


字典树实现
class Trie {

        /**
         * 多叉树结构
         */
        private class Node {
            private boolean isWord;
            private HashMap&amp;lt;Character, Node&amp;gt; next;

            public Node(boolean isWord) {
                this.isWord = isWord;
                this.next = new HashMap&amp;lt;&amp;gt;();
            }

            public Node() {
                this(false);
            }
        }

        private Node root;
        private int size;

        /** Initialize your data structure here. */
        public Trie() {
            // 带虚拟头结点
            this.root = new Node();
            this.size = 0;
        }

        /** Inserts a word into the trie. */
        public void insert(String word) {
            Node cur = root;
            for (int i = 0; i &amp;lt; word.length(); i++) {
                char c = word.charAt(i);
                // 不存在当前字母节点
                if (cur.next.get(c) == null) {
                    cur.next.put(c, new Node());
                }
                // 已经存在当前字母节点，继续向下寻找
                cur = cur.next.get(c);
            }
            // 字母添加完毕，查看当前单词末尾是否已经被标记，若被标记则说明重复添加
            if (!cur.isWord) {
                // 标记为单词末尾
                cur.isWord = true;
                size++;
            }
        }

        /** Returns if the word is in the trie. */
        public boolean search(String word) {
            Node cur = root;
            for (int i = 0; i &amp;lt; word.length(); i++) {
                char c = word.charAt(i);
                if (cur.next.get(c) == null) {
                    return false;
                }
                cur = cur.next.get(c);
            }
            return cur.isWord;
        }

        /** Returns if there is any word in the trie that starts with the given prefix. */
        public boolean startsWith(String prefix) {
            Node cur = root;
            for (int i = 0; i &amp;lt; prefix.length(); i++) {
                char c = prefix.charAt(i);
                if (cur.next.get(c)==null){
                    return false;
                }
                cur = cur.next.get(c);
            }
            return true;
        }
}

第27天 Add and Search Word - Data structure design（211）


题号 211 Add and Search Word - Data structure design


题目描述：

设计一个支持以下两种操作的数据结构：
void addWord(word)
bool search(word)

search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。
示例:
addWord(&amp;quot;bad&amp;quot;)
addWord(&amp;quot;dad&amp;quot;)
addWord(&amp;quot;mad&amp;quot;)
search(&amp;quot;pad&amp;quot;) -&amp;gt; false
search(&amp;quot;bad&amp;quot;) -&amp;gt; true
search(&amp;quot;.ad&amp;quot;) -&amp;gt; true
search(&amp;quot;b..&amp;quot;) -&amp;gt; true

说明:
你可以假设所有单词都是由小写字母 a-z 组成的。



解题思路：字典树实现


心得体会：典型字典树（前缀树）应用场景


字典树实现
class WordDictionary {

        /**
         * 多叉树结构
         */
        private class Node {
            private boolean isWord;
            private HashMap&amp;lt;Character, Node&amp;gt; next;

            public Node(boolean isWord) {
                this.isWord = isWord;
                this.next = new HashMap&amp;lt;&amp;gt;();
            }

            public Node() {
                this(false);
            }
        }

        private Node root;

        /** Initialize your data structure here. */
        public WordDictionary() {
            // 带虚拟头结点
            this.root = new Node();
        }

        /** Adds a word into the data structure. */
        public void addWord(String word) {
            Node cur = root;
            for (int i = 0; i &amp;lt; word.length(); i++) {
                char c = word.charAt(i);
                // 不存在当前字母节点
                if (cur.next.get(c) == null) {
                    cur.next.put(c, new Node());
                }
                // 已经存在当前字母节点，继续向下寻找
                cur = cur.next.get(c);
            }
            // 字母添加完毕，查看当前单词末尾是否已经被标记，若被标记则说明重复添加
            if (!cur.isWord) {
                // 标记为单词末尾
                cur.isWord = true;
            }
        }

        /** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. */
        public boolean search(String word) {
            return match(word,root,0);
        }
        
        private boolean match(String word,Node node,int index){
            // 终止条件
            if (index == word.length()){
                return node.isWord;
            }
            char c = word.charAt(index);
            // 判断通配符
            if (c != &#39;.&#39;){
                if (node.next.get(c)==null){
                    return false;
                }
                return match(word,node.next.get(c),index+1);
            }
            // 遍历当前节点所有的子节点
            for (Character w : node.next.keySet()) {
                // 如果有一个节点返回true则为true
                if (match(word,node.next.get(w),index+1)){
                    return true;
                }
            }
            return false;
        }
    }

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */

第28天 Map Sum Pairs（677）


题号 677 Map Sum Pairs


题目描述：

实现一个 MapSum 类里的两个方法，insert 和 sum。
对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。
对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。
示例 1:
输入: insert(&amp;quot;apple&amp;quot;, 3), 输出: Null
输入: sum(&amp;quot;ap&amp;quot;), 输出: 3
输入: insert(&amp;quot;app&amp;quot;, 2), 输出: Null
输入: sum(&amp;quot;ap&amp;quot;), 输出: 5




解题思路：字典树


心得体会：使用字典树记录字母节点，到节点尾部维护权重值，更新时同时更新权重值即可


字典树实现

第29天 Validate Binary Search Tree（98）


题号 98 Validate Binary Search Tree


题目描述：

给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

示例 1:
输入:
    2
   / \
  1   3
输出: true

示例 2:
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。




解题思路：二叉树中序遍历


心得体会：利用二分搜索树中序遍历有序性的特点，对中序遍历集合进行检查，若发现无序则返回。该解法可进一步优化为在执行中序遍历过程中保留上一次递归结果进行判断，若发现无序则无需遍历所有节点。



第30天 Delete Node in a BST（450）


题号 450 Delete Node in a BST


题目描述：

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

说明： 要求算法时间复杂度为 O(h)，h 为树的高度。
示例:
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7




解题思路：二分搜索树删除节点


心得体会：对于二分搜索树删除节点，此处选择该节点右子树中最小的节点替代被删除节点以保证二分搜索树的性质，相反，也可以通过使用该节点的左子树中最大的节点替代。



第31天 Binary Tree Level Order Traversal（102）


题号 102 Binary Tree Level Order Traversal


题目描述：

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]




解题思路：二分搜索树层次遍历


心得体会：与[107题](#第12天 Binary Tree Level Order Traversal II（107)类似



第32天 Binary Search Tree Iterator（173）


题号 173 Binary Search Tree Iterator


题目描述：

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。
调用 next() 将返回二叉搜索树中的下一个最小的数。
示例：

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false

提示：

next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。




解题思路：使用栈或者队列实现


心得体会：比较简单的方式是使用队列存储中序遍历集合，依次出队则保证为树中最小的元素，也评论区看到栈的解法，时间复杂度更低，但实现相对复杂


队列解法

栈解法
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
    
    private Stack&amp;lt;TreeNode&amp;gt; stack;
    public BSTIterator(TreeNode root) {
        stack = new Stack&amp;lt;&amp;gt;();
        TreeNode cur = root;
        while(cur != null){
            stack.push(cur);
            if(cur.left != null)
                cur = cur.left;
            else
                break;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode node = stack.pop();
        TreeNode cur = node;
        // traversal right branch
        if(cur.right != null){
            cur = cur.right;
            while(cur != null){
                stack.push(cur);
                if(cur.left != null)
                    cur = cur.left;
                else
                    break;
            }
        }
        return node.val;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://fjiayang.github.io//post/leetcode-shua-ti-ji-lu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://fjiayang.github.io//post/kubernetes-ji-chu-ming-ling-xue-xi">
                        Kubernetes基础命令学习
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-20</time>
                    
                        <a href="https://fjiayang.github.io//tag/VwGnvPo1M" class="post-tag i-tag
                            i-tag-primary">
            #学习
        </a>
                        
                        <a href="https://fjiayang.github.io//tag/yb4HlP89R" class="post-tag i-tag
                            i-tag-banana">
            #Kubernetes
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://fjiayang.github.io//post/kubernetes-ji-chu-ming-ling-xue-xi" class="post-feature-image" style="background-image:url(https://s2.ax1x.com/2019/11/27/QC2UuF.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            配置命令语法提示
执行命令查看指南
$ kubectl completion -h
Output shell completion code for the specified shell (bash or zsh). The shell code must be evaluated to provide
interactive completion of kubectl commands.  This can be done by sourcing it from the .bash_profile.

 Detailed instructions on how to do this are available here:
https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion

 Note for zsh users: [1] zsh completions are only supported in versions of zsh &amp;gt;= 5.2

Examples:
  # Installing bash completion on macOS using homebrew
  ## If running Bash 3.2 included with macOS
  brew install bash-completion
  ## or, if running Bash 4.1+
  brew install bash-completion@2
  ## If kubectl is installed via homebrew, this should start working immediately.
  ## If you&#39;ve installed via other means, you may need add the completion to your completion directory
  kubectl completion bash &amp;gt; $(brew --prefix)/etc/bash_completion.d/kubectl


  # Installing bash completion on Linux
  ## If bash-completion is not installed on Linux, please install the &#39;bash-completion&#39; package
  ## via your distribution&#39;s package manager.
  ## Load the kubectl completion code for bash into the current shell
  source &amp;lt;(kubectl completion bash)
  ## Write bash completion code to a file and source if from .bash_profile
  kubectl completion bash &amp;gt; ~/.kube/completion.bash.inc
  printf &amp;quot;
  # Kubectl shell completion
  source &#39;$HOME/.kube/completion.bash.inc&#39;
  &amp;quot; &amp;gt;&amp;gt; $HOME/.bash_profile
  source $HOME/.bash_profile

  # Load the kubectl completion code for zsh[1] into the current shell
  source &amp;lt;(kubectl completion zsh)
  # Set the kubectl completion code for zsh[1] to autoload on startup
  kubectl completion zsh &amp;gt; &amp;quot;${fpath[1]}/_kubectl&amp;quot;

Usage:
  kubectl completion SHELL [options]

Use &amp;quot;kubectl options&amp;quot; for a list of global command-line options (applies to all commands).

按照指南操作即可
配置多个上下文环境
查看当前上下文配置
$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO           NAMESPACE
*         minikube   minikube   minikube

编辑~/.kube/config文件新增需要的上下文配置即可，配置完成后查看上下文信息
$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO           NAMESPACE
          kubeadm    kubeadm    kubernetes-admin
*         minikube   minikube   minikube

切换上下文
$ kubectl config use-context kubeadm
Switched to context &amp;quot;kubeadm&amp;quot;.

再次查看，可见切换成功
$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO           NAMESPACE
*         kubeadm    kubeadm    kubernetes-admin
          minikube   minikube   minikube

Pod相关操作
默认查看default命名空间的Pod
$ kubectl get pod
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-54f57cf6bf-pznmh   1/1     Running   0          52s
nginx-deployment-54f57cf6bf-r9q89   1/1     Running   0          52s

查看所有命名空间的Pod
$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
kube-system   coredns-58cc8c89f4-c297b             1/1     Running   0          10m
kube-system   coredns-58cc8c89f4-spzhj             1/1     Running   0          10m
kube-system   etcd-k8s-master                      1/1     Running   0          9m57s
kube-system   kube-apiserver-k8s-master            1/1     Running   0          10m
kube-system   kube-controller-manager-k8s-master   1/1     Running   0          9m58s
kube-system   kube-flannel-ds-amd64-6fwg5          1/1     Running   0          5m
kube-system   kube-flannel-ds-amd64-6rchg          1/1     Running   0          9m12s
kube-system   kube-flannel-ds-amd64-z4plh          1/1     Running   0          4m54s
kube-system   kube-proxy-cdcs4                     1/1     Running   0          5m
kube-system   kube-proxy-nlmbb                     1/1     Running   0          4m54s
kube-system   kube-proxy-xlb62                     1/1     Running   0          10m
kube-system   kube-scheduler-k8s-master            1/1     Running   0          10m

指定Pod对应的app名称
$ kubectl get pod -l app=nginx
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-54f57cf6bf-pznmh   1/1     Running   0          58s
nginx-deployment-54f57cf6bf-r9q89   1/1     Running   0          58s

查看更多信息
$ kubectl get deployment -o wide
NAME               READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES        SELECTOR
nginx-deployment   2/2     2            2           64s   nginx        nginx:1.7.9   app=nginx

查看Pod详细信息
$ kubectl describe pod
Name:         nginx-deployment-54f57cf6bf-67llv
Namespace:    default
Priority:     0
Node:         k8s-node1/10.0.2.15
Start Time:   Sun, 20 Oct 2019 10:19:42 +0800
Labels:       app=nginx
              pod-template-hash=54f57cf6bf
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           172.100.1.3
IPs:
  IP:           172.100.1.3
Controlled By:  ReplicaSet/nginx-deployment-54f57cf6bf
Containers:
  nginx:
    Container ID:   docker://ffd4b4fa3fd4678a61797cfdcba31ea2b0b36459b65a95100484eda4be286b9f
    Image:          nginx:1.7.9
    Image ID:       docker-pullable://nginx@sha256:e3456c851a152494c3e4ff5fcc26f240206abac0c9d794affb40e0714846c451
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 20 Oct 2019 10:19:45 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-zjpq9 (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  default-token-zjpq9:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-zjpq9
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age        From                Message
  ----    ------     ----       ----                -------
  Normal  Scheduled  &amp;lt;unknown&amp;gt;  default-scheduler   Successfully assigned default/nginx-deployment-54f57cf6bf-67llv to k8s-node1
  Normal  Pulled     46s        kubelet, k8s-node1  Container image &amp;quot;nginx:1.7.9&amp;quot; already present on machine
  Normal  Created    46s        kubelet, k8s-node1  Created container nginx
  Normal  Started    45s        kubelet, k8s-node1  Started container nginx


Name:         nginx-deployment-54f57cf6bf-r9q89
Namespace:    default
Priority:     0
Node:         k8s-node2/10.0.2.15
Start Time:   Sun, 20 Oct 2019 10:17:24 +0800
Labels:       app=nginx
              pod-template-hash=54f57cf6bf
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           172.100.2.3
IPs:
  IP:           172.100.2.3
Controlled By:  ReplicaSet/nginx-deployment-54f57cf6bf
Containers:
  nginx:
    Container ID:   docker://61894b3762d723eabe2510284bb107098bdbcb8da4f841eea863a9c7a59c5806
    Image:          nginx:1.7.9
    Image ID:       docker-pullable://nginx@sha256:e3456c851a152494c3e4ff5fcc26f240206abac0c9d794affb40e0714846c451
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 20 Oct 2019 10:18:08 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-zjpq9 (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  default-token-zjpq9:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-zjpq9
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age        From                Message
  ----    ------     ----       ----                -------
  Normal  Scheduled  &amp;lt;unknown&amp;gt;  default-scheduler   Successfully assigned default/nginx-deployment-54f57cf6bf-r9q89 to k8s-node2
  Normal  Pulling    3m4s       kubelet, k8s-node2  Pulling image &amp;quot;nginx:1.7.9&amp;quot;
  Normal  Pulled     2m24s      kubelet, k8s-node2  Successfully pulled image &amp;quot;nginx:1.7.9&amp;quot;
  Normal  Created    2m22s      kubelet, k8s-node2  Created container nginx
  Normal  Started    2m22s      kubelet, k8s-node2  Started container nginx

Deployment相关操作
部署Deployment
$ kubectl create -f nginx_deployment.yml
deployment.apps/nginx-deployment created

升级Deployment
apply兼有create的语义，故也可直接使用apply创建\部署deployment
$ kubectl apply -f nginx_deployment_scale.yml
deployment.apps/nginx-deployment configured

查看Deployment更多信息
$ kubectl get deployment -o wide
NAME               READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES      SELECTOR
nginx-deployment   2/2     2            2           5m28s   nginx        nginx:1.8   app=nginx

查看详细信息
$ kubectl describe deployments.apps
Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 20 Oct 2019 10:17:24 +0800
Labels:                 &amp;lt;none&amp;gt;
Annotations:            deployment.kubernetes.io/revision: 3
                        kubectl.kubernetes.io/last-applied-configuration:
                          {&amp;quot;apiVersion&amp;quot;:&amp;quot;apps/v1&amp;quot;,&amp;quot;kind&amp;quot;:&amp;quot;Deployment&amp;quot;,&amp;quot;metadata&amp;quot;:{&amp;quot;annotations&amp;quot;:{},&amp;quot;name&amp;quot;:&amp;quot;nginx-deployment&amp;quot;,&amp;quot;namespace&amp;quot;:&amp;quot;default&amp;quot;},&amp;quot;spec&amp;quot;:{&amp;quot;replica...
Selector:               app=nginx
Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.9.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Progressing    True    NewReplicaSetAvailable
  Available      True    MinimumReplicasAvailable
OldReplicaSets:  &amp;lt;none&amp;gt;
NewReplicaSet:   nginx-deployment-56f8998dbc (2/2 replicas created)
Events:
  Type    Reason             Age                  From                   Message
  ----    ------             ----                 ----                   -------
  Normal  ScalingReplicaSet  22m                  deployment-controller  Scaled up replica set nginx-deployment-54f57cf6bf to 2
  Normal  ScalingReplicaSet  18m                  deployment-controller  Scaled up replica set nginx-deployment-9f46bb5 to 1
  Normal  ScalingReplicaSet  17m                  deployment-controller  Scaled down replica set nginx-deployment-54f57cf6bf to 1
  Normal  ScalingReplicaSet  17m                  deployment-controller  Scaled up replica set nginx-deployment-9f46bb5 to 2
  Normal  ScalingReplicaSet  16m                  deployment-controller  Scaled down replica set nginx-deployment-54f57cf6bf to 0
  Normal  ScalingReplicaSet  15m                  deployment-controller  Scaled up replica set nginx-deployment-9f46bb5 to 4
  Normal  ScalingReplicaSet  12m                  deployment-controller  Scaled down replica set nginx-deployment-9f46bb5 to 3
  Normal  ScalingReplicaSet  6m25s                deployment-controller  Scaled up replica set nginx-deployment-56f8998dbc to 1
  Normal  ScalingReplicaSet  5m43s                deployment-controller  Scaled down replica set nginx-deployment-9f46bb5 to 2
  Normal  ScalingReplicaSet  63s (x6 over 5m43s)  deployment-controller  (combined from similar events): Scaled down replica set nginx-deployment-56f8998dbc to 2

Node相关
查看Node
$ kubectl get nodes
NAME         STATUS   ROLES    AGE   VERSION
k8s-master   Ready    master   24m   v1.16.2
k8s-node1    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2
k8s-node2    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2

查看更多信息
$ kubectl get nodes -o wide
NAME         STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME
k8s-master   Ready    master   24m   v1.16.2   10.0.2.15     &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://18.9.8
k8s-node1    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2   10.0.2.15     &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://18.9.8
k8s-node2    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2   10.0.2.15     &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://18.9.8

查看标签
$ kubectl get nodes --show-labels
NAME         STATUS   ROLES    AGE   VERSION   LABELS
k8s-master   Ready    master   24m   v1.16.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/master=
k8s-node1    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linux
k8s-node2    Ready    &amp;lt;none&amp;gt;   18m   v1.16.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node2,kubernetes.io/os=linux

设置角色标签
$ kubectl label nodes k8s-node1 node-role.kubernetes.io/worker=
node/k8s-node1 labeled

查看详细信息
$ kubectl describe nodes
Name:               k8s-master
Roles:              master
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=k8s-master
                    kubernetes.io/os=linux
                    node-role.kubernetes.io/master=
Annotations:        flannel.alpha.coreos.com/backend-data: {&amp;quot;VtepMAC&amp;quot;:&amp;quot;32:38:c5:18:f0:ed&amp;quot;}
                    flannel.alpha.coreos.com/backend-type: vxlan
                    flannel.alpha.coreos.com/kube-subnet-manager: true
                    flannel.alpha.coreos.com/public-ip: 10.0.2.15
                    kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Sun, 20 Oct 2019 10:05:02 +0800
Taints:             node-role.kubernetes.io/master:NoSchedule
Unschedulable:      false
Conditions:
  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message
  ----             ------  -----------------                 ------------------                ------                       -------
  MemoryPressure   False   Sun, 20 Oct 2019 10:27:46 +0800   Sun, 20 Oct 2019 10:05:02 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available
  DiskPressure     False   Sun, 20 Oct 2019 10:27:46 +0800   Sun, 20 Oct 2019 10:05:02 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure
  PIDPressure      False   Sun, 20 Oct 2019 10:27:46 +0800   Sun, 20 Oct 2019 10:05:02 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available
  Ready            True    Sun, 20 Oct 2019 10:27:46 +0800   Sun, 20 Oct 2019 10:07:42 +0800   KubeletReady                 kubelet is posting ready status
Addresses:
  InternalIP:  10.0.2.15
  Hostname:    k8s-master
Capacity:
 cpu:                2
 ephemeral-storage:  41921540Ki
 hugepages-2Mi:      0
 memory:             1882144Ki
 pods:               110
Allocatable:
 cpu:                2
 ephemeral-storage:  38634891201
 hugepages-2Mi:      0
 memory:             1779744Ki
 pods:               110
System Info:
 Machine ID:                 d74c50274729456aad2a6198de9863b3
 System UUID:                D74C5027-4729-456A-AD2A-6198DE9863B3
 Boot ID:                    fb2ea7bd-afb2-4051-afb7-78d9f59ec6f6
 Kernel Version:             3.10.0-957.12.2.el7.x86_64
 OS Image:                   CentOS Linux 7 (Core)
 Operating System:           linux
 Architecture:               amd64
 Container Runtime Version:  docker://18.9.8
 Kubelet Version:            v1.16.2
 Kube-Proxy Version:         v1.16.2
PodCIDR:                     172.100.0.0/24
PodCIDRs:                    172.100.0.0/24
Non-terminated Pods:         (8 in total)
  Namespace                  Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits  AGE
  ---------                  ----                                  ------------  ----------  ---------------  -------------  ---
  kube-system                coredns-58cc8c89f4-c297b              100m (5%)     0 (0%)      70Mi (4%)        170Mi (9%)     23m
  kube-system                coredns-58cc8c89f4-spzhj              100m (5%)     0 (0%)      70Mi (4%)        170Mi (9%)     23m
  kube-system                etcd-k8s-master                       0 (0%)        0 (0%)      0 (0%)           0 (0%)         22m
  kube-system                kube-apiserver-k8s-master             250m (12%)    0 (0%)      0 (0%)           0 (0%)         22m
  kube-system                kube-controller-manager-k8s-master    200m (10%)    0 (0%)      0 (0%)           0 (0%)         22m
  kube-system                kube-flannel-ds-amd64-6rchg           100m (5%)     100m (5%)   50Mi (2%)        50Mi (2%)      21m
  kube-system                kube-proxy-xlb62                      0 (0%)        0 (0%)      0 (0%)           0 (0%)         23m
  kube-system                kube-scheduler-k8s-master             100m (5%)     0 (0%)      0 (0%)           0 (0%)         22m
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests     Limits
  --------           --------     ------
  cpu                850m (42%)   100m (5%)
  memory             190Mi (10%)  390Mi (22%)
  ephemeral-storage  0 (0%)       0 (0%)
Events:
  Type    Reason                   Age                From                    Message
  ----    ------                   ----               ----                    -------
  Normal  NodeHasSufficientMemory  23m (x8 over 23m)  kubelet, k8s-master     Node k8s-master status is now: NodeHasSufficientMemory
  Normal  NodeHasNoDiskPressure    23m (x8 over 23m)  kubelet, k8s-master     Node k8s-master status is now: NodeHasNoDiskPressure
  Normal  NodeHasSufficientPID     23m (x7 over 23m)  kubelet, k8s-master     Node k8s-master status is now: NodeHasSufficientPID
  Normal  Starting                 23m                kube-proxy, k8s-master  Starting kube-proxy.


Name:               k8s-node1
Roles:              &amp;lt;none&amp;gt;
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=k8s-node1
                    kubernetes.io/os=linux
Annotations:        flannel.alpha.coreos.com/backend-data: {&amp;quot;VtepMAC&amp;quot;:&amp;quot;16:5c:40:b1:14:b6&amp;quot;}
                    flannel.alpha.coreos.com/backend-type: vxlan
                    flannel.alpha.coreos.com/kube-subnet-manager: true
                    flannel.alpha.coreos.com/public-ip: 10.0.2.15
                    kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Sun, 20 Oct 2019 10:11:03 +0800
Taints:             &amp;lt;none&amp;gt;
Unschedulable:      false
Conditions:
  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message
  ----             ------  -----------------                 ------------------                ------                       -------
  MemoryPressure   False   Sun, 20 Oct 2019 10:28:08 +0800   Sun, 20 Oct 2019 10:11:03 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available
  DiskPressure     False   Sun, 20 Oct 2019 10:28:08 +0800   Sun, 20 Oct 2019 10:11:03 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure
  PIDPressure      False   Sun, 20 Oct 2019 10:28:08 +0800   Sun, 20 Oct 2019 10:11:03 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available
  Ready            True    Sun, 20 Oct 2019 10:28:08 +0800   Sun, 20 Oct 2019 10:11:34 +0800   KubeletReady                 kubelet is posting ready status
Addresses:
  InternalIP:  10.0.2.15
  Hostname:    k8s-node1
Capacity:
 cpu:                1
 ephemeral-storage:  41921540Ki
 hugepages-2Mi:      0
 memory:             1882296Ki
 pods:               110
Allocatable:
 cpu:                1
 ephemeral-storage:  38634891201
 hugepages-2Mi:      0
 memory:             1779896Ki
 pods:               110
System Info:
 Machine ID:                 5d806dde9b0444bdb5c9800a228267d8
 System UUID:                5D806DDE-9B04-44BD-B5C9-800A228267D8
 Boot ID:                    e6b7222c-686c-49cb-8e56-9bb263852d36
 Kernel Version:             3.10.0-957.12.2.el7.x86_64
 OS Image:                   CentOS Linux 7 (Core)
 Operating System:           linux
 Architecture:               amd64
 Container Runtime Version:  docker://18.9.8
 Kubelet Version:            v1.16.2
 Kube-Proxy Version:         v1.16.2
PodCIDR:                     172.100.1.0/24
PodCIDRs:                    172.100.1.0/24
Non-terminated Pods:         (4 in total)
  Namespace                  Name                              CPU Requests  CPU Limits  Memory Requests  Memory Limits  AGE
  ---------                  ----                              ------------  ----------  ---------------  -------------  ---
  default                    nginx-deployment-9f46bb5-7vlb7    0 (0%)        0 (0%)      0 (0%)           0 (0%)         3m53s
  default                    nginx-deployment-9f46bb5-c7czx    0 (0%)        0 (0%)      0 (0%)           0 (0%)         6m35s
  kube-system                kube-flannel-ds-amd64-6fwg5       100m (10%)    100m (10%)  50Mi (2%)        50Mi (2%)      17m
  kube-system                kube-proxy-cdcs4                  0 (0%)        0 (0%)      0 (0%)           0 (0%)         17m
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests    Limits
  --------           --------    ------
  cpu                100m (10%)  100m (10%)
  memory             50Mi (2%)   50Mi (2%)
  ephemeral-storage  0 (0%)      0 (0%)
Events:
  Type    Reason                   Age   From                   Message
  ----    ------                   ----  ----                   -------
  Normal  Starting                 17m   kubelet, k8s-node1     Starting kubelet.
  Normal  NodeHasSufficientMemory  17m   kubelet, k8s-node1     Node k8s-node1 status is now: NodeHasSufficientMemory
  Normal  NodeHasNoDiskPressure    17m   kubelet, k8s-node1     Node k8s-node1 status is now: NodeHasNoDiskPressure
  Normal  NodeHasSufficientPID     17m   kubelet, k8s-node1     Node k8s-node1 status is now: NodeHasSufficientPID
  Normal  NodeAllocatableEnforced  17m   kubelet, k8s-node1     Updated Node Allocatable limit across pods
  Normal  Starting                 17m   kube-proxy, k8s-node1  Starting kube-proxy.
  Normal  NodeReady                16m   kubelet, k8s-node1     Node k8s-node1 status is now: NodeReady


Name:               k8s-node2
Roles:              &amp;lt;none&amp;gt;
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=k8s-node2
                    kubernetes.io/os=linux
Annotations:        flannel.alpha.coreos.com/backend-data: {&amp;quot;VtepMAC&amp;quot;:&amp;quot;76:49:24:1f:e5:d6&amp;quot;}
                    flannel.alpha.coreos.com/backend-type: vxlan
                    flannel.alpha.coreos.com/kube-subnet-manager: true
                    flannel.alpha.coreos.com/public-ip: 10.0.2.15
                    kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Sun, 20 Oct 2019 10:11:09 +0800
Taints:             &amp;lt;none&amp;gt;
Unschedulable:      false
Conditions:
  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message
  ----             ------  -----------------                 ------------------                ------                       -------
  MemoryPressure   False   Sun, 20 Oct 2019 10:27:42 +0800   Sun, 20 Oct 2019 10:11:09 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available
  DiskPressure     False   Sun, 20 Oct 2019 10:27:42 +0800   Sun, 20 Oct 2019 10:11:09 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure
  PIDPressure      False   Sun, 20 Oct 2019 10:27:42 +0800   Sun, 20 Oct 2019 10:11:09 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available
  Ready            True    Sun, 20 Oct 2019 10:27:42 +0800   Sun, 20 Oct 2019 10:11:40 +0800   KubeletReady                 kubelet is posting ready status
Addresses:
  InternalIP:  10.0.2.15
  Hostname:    k8s-node2
Capacity:
 cpu:                1
 ephemeral-storage:  41921540Ki
 hugepages-2Mi:      0
 memory:             1882296Ki
 pods:               110
Allocatable:
 cpu:                1
 ephemeral-storage:  38634891201
 hugepages-2Mi:      0
 memory:             1779896Ki
 pods:               110
System Info:
 Machine ID:                 7c59ba12638e4fdfa20cfeda0aa2fda1
 System UUID:                7C59BA12-638E-4FDF-A20C-FEDA0AA2FDA1
 Boot ID:                    e402f75c-42e7-454d-aaca-f96853091c15
 Kernel Version:             3.10.0-957.12.2.el7.x86_64
 OS Image:                   CentOS Linux 7 (Core)
 Operating System:           linux
 Architecture:               amd64
 Container Runtime Version:  docker://18.9.8
 Kubelet Version:            v1.16.2
 Kube-Proxy Version:         v1.16.2
PodCIDR:                     172.100.2.0/24
PodCIDRs:                    172.100.2.0/24
Non-terminated Pods:         (3 in total)
  Namespace                  Name                              CPU Requests  CPU Limits  Memory Requests  Memory Limits  AGE
  ---------                  ----                              ------------  ----------  ---------------  -------------  ---
  default                    nginx-deployment-9f46bb5-mv4b7    0 (0%)        0 (0%)      0 (0%)           0 (0%)         5m52s
  kube-system                kube-flannel-ds-amd64-z4plh       100m (10%)    100m (10%)  50Mi (2%)        50Mi (2%)      17m
  kube-system                kube-proxy-nlmbb                  0 (0%)        0 (0%)      0 (0%)           0 (0%)         17m
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests    Limits
  --------           --------    ------
  cpu                100m (10%)  100m (10%)
  memory             50Mi (2%)   50Mi (2%)
  ephemeral-storage  0 (0%)      0 (0%)
Events:
  Type    Reason                   Age   From                   Message
  ----    ------                   ----  ----                   -------
  Normal  Starting                 17m   kubelet, k8s-node2     Starting kubelet.
  Normal  NodeHasSufficientMemory  17m   kubelet, k8s-node2     Node k8s-node2 status is now: NodeHasSufficientMemory
  Normal  NodeHasNoDiskPressure    17m   kubelet, k8s-node2     Node k8s-node2 status is now: NodeHasNoDiskPressure
  Normal  NodeHasSufficientPID     17m   kubelet, k8s-node2     Node k8s-node2 status is now: NodeHasSufficientPID
  Normal  NodeAllocatableEnforced  17m   kubelet, k8s-node2     Updated Node Allocatable limit across pods
  Normal  Starting                 17m   kube-proxy, k8s-node2  Starting kube-proxy.
  Normal  NodeReady                16m   kubelet, k8s-node2     Node k8s-node2 status is now: NodeReady

服务伸缩
scale命令方式
$ kubectl scale --replicas=6 deployment/nginx-deployment
deployment.apps/nginx-deployment scaled

查看副本数
$ kubectl get replicaset
NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-54f57cf6bf   0         0         0       21m
nginx-deployment-56f8998dbc   6         6         3       5m7s
nginx-deployment-9f46bb5      0         0         0       16m


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://fjiayang.github.io//post/kubernetes-ji-chu-ming-ling-xue-xi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://fjiayang.github.io//post/kubernetes-ji-qun-da-jian">
                        Kubernetes 集群搭建
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-20</time>
                    
                        <a href="https://fjiayang.github.io//tag/yb4HlP89R" class="post-tag i-tag
                            i-tag-other_3">
            #Kubernetes
        </a>
                        
                        <a href="https://fjiayang.github.io//tag/kTPZcu1_NZ" class="post-tag i-tag
                            i-tag-">
            #Docker
        </a>
                        
                        <a href="https://fjiayang.github.io//tag/rjmWDGdyvm" class="post-tag i-tag
                            i-tag-">
            #集群
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://fjiayang.github.io//post/kubernetes-ji-qun-da-jian" class="post-feature-image" style="background-image:url(https://s2.ax1x.com/2019/11/27/QCRTo9.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            搭建方法分类
如果是搭建Kubernetes的学习环境，则可以直接使用minikube快速搭建单节点的Kubernetes环境，官方推荐使用kubeadm搭建Kubernetes集群生产环境
但kubeadm需要连接谷歌容器仓库获取镜像，在网络受限的情况下无法搭建成功，故有两种搭建方法：

服务器使用代理，代理所有的http和https连接，可以自由访问任意地址
使用阿里云镜像地址

本次采用第二种方式进行搭建
环境准备
本次宿主机为CentOS 7，结合3台virtual box虚拟机模拟集群环境，虚拟机使用Vagrant进行管理，vagrant安装比较简单，此处不再赘述
宿主机配置：

CPU：4C
RAM：8G

虚拟机配置
由于网络受限，vagrant默认拉取的操作系统文件地址不可访问，需要自行从官方下载镜像或者使用代理下载镜像，此处对此操作也不再赘述
三台虚拟机配置文件
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version &amp;quot;&amp;gt;= 1.6.0&amp;quot;

boxes = [
    {
        :name =&amp;gt; &amp;quot;k8s-master&amp;quot;,
        :eth1 =&amp;gt; &amp;quot;192.168.205.120&amp;quot;,
        :mem =&amp;gt; &amp;quot;2048&amp;quot;,
        :cpu =&amp;gt; &amp;quot;2&amp;quot;
    },
    {
        :name =&amp;gt; &amp;quot;k8s-node1&amp;quot;,
        :eth1 =&amp;gt; &amp;quot;192.168.205.121&amp;quot;,
        :mem =&amp;gt; &amp;quot;2048&amp;quot;,
        :cpu =&amp;gt; &amp;quot;1&amp;quot;
    },
    {
        :name =&amp;gt; &amp;quot;k8s-node2&amp;quot;,
        :eth1 =&amp;gt; &amp;quot;192.168.205.122&amp;quot;,
        :mem =&amp;gt; &amp;quot;2048&amp;quot;,
        :cpu =&amp;gt; &amp;quot;1&amp;quot;
    }

]

Vagrant.configure(2) do |config|

  config.vm.box = &amp;quot;centos/7&amp;quot;
  boxes.each do |opts|
    config.vm.define opts[:name] do |config|
      config.vm.hostname = opts[:name]
      config.vm.provider &amp;quot;vmware_fusion&amp;quot; do |v|
        v.vmx[&amp;quot;memsize&amp;quot;] = opts[:mem]
        v.vmx[&amp;quot;numvcpus&amp;quot;] = opts[:cpu]
      end
      config.vm.provider &amp;quot;virtualbox&amp;quot; do |v|
        v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--memory&amp;quot;, opts[:mem]]
        v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--cpus&amp;quot;, opts[:cpu]]
      end
      config.vm.network :private_network, ip: opts[:eth1]
    end
  end
  config.vm.provision &amp;quot;shell&amp;quot;, privileged: true, path: &amp;quot;./setup.sh&amp;quot;
end

所有虚拟机启动后都会执行./setup.sh脚本配置基础环境，脚本内容如下
#/bin/sh

sudo yum install -y vim telnet bind-utils wget yum-utils

sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
sudo yum -y install docker-ce-18.09.8 docker-ce-cli-18.09.8 containerd.io

if [ ! $(getent group docker) ];
then 
    sudo groupadd docker;
else
    echo &amp;quot;docker user group already exists&amp;quot;
fi

sudo gpasswd -a $USER docker
sudo systemctl restart docker

# open password auth for backup if ssh key doesn&#39;t work, bydefault, username=vagrant password=vagrant
sudo sed -i &#39;s/PasswordAuthentication no/PasswordAuthentication yes/g&#39; /etc/ssh/sshd_config
sudo systemctl restart sshd

sudomkdir /etc/yum.repos.d/bak &amp;amp;&amp;amp; mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak
sudowget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo
sudowget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo

yum clean all &amp;amp;&amp;amp; yum makecache

sudo bash -c &#39;cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF&#39;

sudo wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://clayphwh.mirror.aliyuncs.com&amp;quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker

sudo setenforce 0

sudo yum install -y kubelet kubeadm kubectl

sudo bash -c &#39;cat &amp;lt;&amp;lt;EOF &amp;gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward=1
EOF&#39;
sudo sysctl --system

sudo systemctl stop firewalld
sudo systemctl disable firewalld
sudo swapoff -a

sudo systemctl enable docker.service
sudo systemctl enable kubelet.service

脚本内已将K8S镜像均配置为阿里云镜像仓库，并配置了阿里云容器加速服务地址，更便于在国内拉取镜像
启动虚拟机
使用命令启动虚拟机
$ vagrant up

启动需要较长时间，若出现大量超时也请耐心等待
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.163.com
 * updates: mirrors.163.com
http://vault.centos.org/7.1.1503/os/x86_64/repodata/0e6e90965f55146ba5025ea450f822d1bb0267d0299ef64dd4365825e6bad995-c7-x86_64-comps.xml.gz: [Errno 12] Timeout on http://vault.centos.org/7.1.1503/os/x86_64/repodata/0e6e90965f55146ba5025ea450f822d1bb0267d0299ef64dd4365825e6bad995-c7-x86_64-comps.xml.gz: (28, &#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;)
Trying other mirror.
http://vault.centos.org/7.1.1503/updates/x86_64/repodata/93b71f445d2ec2138d28152612f4fb29c8e76ee31f2666b964d88249b4e0a955-primary.sqlite.bz2: [Errno 12] Timeout on http://vault.centos.org/7.1.1503/updates/x86_64/repodata/93b71f445d2ec2138d28152612f4fb29c8e76ee31f2666b964d88249b4e0a955-primary.sqlite.bz2: (28, &#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;)
Trying other mirror.
http://vault.centos.org/7.2.1511/os/x86_64/repodata/c6411f1cc8a000ed2b651b49134631d279abba1ec1f78e5dcca79a52d8c1eada-primary.sqlite.bz2: [Errno 12] Timeout on http://vault.centos.org/7.2.1511/os/x86_64/repodata/c6411f1cc8a000ed2b651b49134631d279abba1ec1f78e5dcca79a52d8c1eada-primary.sqlite.bz2: (28, &#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;)
Trying other mirror.
...

启动完成后通过命令查看虚拟机状态
$ vagrant status
Current machine states:

k8s-master                running (virtualbox)
k8s-node1                 running (virtualbox)
k8s-node2                 running (virtualbox)

This environment represents multiple VMs. The VMs are all listed
above with their current state. For more information about a specific
VM, run `vagrant status NAME`.

K8S master节点初始化
进入主节点，查看环境是否已经配置完成
$ vagrant ssh k8s-master

执行以下三条语句查看是否有预期输出
[vagrant@k8s-master ~]$ sudo which kubeadm
/bin/kubeadm
[vagrant@k8s-master ~]$ sudo which kubelet
/bin/kubelet
[vagrant@k8s-master ~]$ sudo which kubectl
/bin/kubectl
[vagrant@k8s-master ~]$ sudo docker version
Client:
 Version:           18.09.8
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        0dd43dd87f
 Built:             Wed Jul 17 17:40:31 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.8
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.8
  Git commit:       0dd43dd
  Built:            Wed Jul 17 17:10:42 2019
  OS/Arch:          linux/amd64
  Experimental:     false

使用初始化命令，并指定拉取镜像地址为阿里云地址，同时指定容器网络地址和注册中心广播地址
$ sudo kubeadm init --pod-network-cidr 172.100.0.0/16 --image-repository registry.aliyuncs.com/google_containers --apiserver-advertise-address 192.168.205.120

输出如下即初始化完成
$ sudo kubeadm init --pod-network-cidr 172.100.0.0/16 --image-repository registry.aliyuncs.com/google_containers --apiserver-advertise-address 192.168.205.120
W1020 01:31:27.560129   20473 version.go:101] could not fetch a `Kubernetes`version from the internet: unable to get URL &amp;quot;https://dl.k8s.io/release/stable-1.txt&amp;quot;: Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
W1020 01:31:27.560713   20473 version.go:102] falling back to the local client version: v1.16.2
[init] Using `Kubernetes`version: v1.16.2
[preflight] Running pre-flight checks
        [WARNING IsDockerSystemdCheck]: detected &amp;quot;cgroupfs&amp;quot; as the Docker cgroup driver. The recommended driver is &amp;quot;systemd&amp;quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Pulling images required for setting up a `Kubernetes`cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;
[kubelet-start] Writing kubelet environment file with flags to file &amp;quot;/var/lib/kubelet/kubeadm-flags.env&amp;quot;
[kubelet-start] Writing kubelet configuration to file &amp;quot;/var/lib/kubelet/config.yaml&amp;quot;
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder &amp;quot;/etc/kubernetes/pki&amp;quot;
[certs] Generating &amp;quot;ca&amp;quot; certificate and key
[certs] Generating &amp;quot;apiserver&amp;quot; certificate and key
[certs] apiserver serving cert is signed for DNS names [k8s-master `kubernetes`kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.205.120]
[certs] Generating &amp;quot;apiserver-kubelet-client&amp;quot; certificate and key
[certs] Generating &amp;quot;front-proxy-ca&amp;quot; certificate and key
[certs] Generating &amp;quot;front-proxy-client&amp;quot; certificate and key
[certs] Generating &amp;quot;etcd/ca&amp;quot; certificate and key
[certs] Generating &amp;quot;etcd/server&amp;quot; certificate and key
[certs] etcd/server serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.205.120 127.0.0.1 ::1]
[certs] Generating &amp;quot;etcd/peer&amp;quot; certificate and key
[certs] etcd/peer serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.205.120 127.0.0.1 ::1]
[certs] Generating &amp;quot;etcd/healthcheck-client&amp;quot; certificate and key
[certs] Generating &amp;quot;apiserver-etcd-client&amp;quot; certificate and key
[certs] Generating &amp;quot;sa&amp;quot; key and public key
[kubeconfig] Using kubeconfig folder &amp;quot;/etc/kubernetes&amp;quot;
[kubeconfig] Writing &amp;quot;admin.conf&amp;quot; kubeconfig file
[kubeconfig] Writing &amp;quot;kubelet.conf&amp;quot; kubeconfig file
[kubeconfig] Writing &amp;quot;controller-manager.conf&amp;quot; kubeconfig file
[kubeconfig] Writing &amp;quot;scheduler.conf&amp;quot; kubeconfig file
[control-plane] Using manifest folder &amp;quot;/etc/kubernetes/manifests&amp;quot;
[control-plane] Creating static Pod manifest for &amp;quot;kube-apiserver&amp;quot;
[control-plane] Creating static Pod manifest for &amp;quot;kube-controller-manager&amp;quot;
[control-plane] Creating static Pod manifest for &amp;quot;kube-scheduler&amp;quot;
[etcd] Creating static Pod manifest for local etcd in &amp;quot;/etc/kubernetes/manifests&amp;quot;
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &amp;quot;/etc/kubernetes/manifests&amp;quot;. This can take up to 4m0s
[kubelet-check] Initial timeout of 40s passed.
[apiclient] All control plane components are healthy after 59.511578 seconds
[upload-config] Storing the configuration used in ConfigMap &amp;quot;kubeadm-config&amp;quot; in the &amp;quot;kube-system&amp;quot; Namespace
[kubelet] Creating a ConfigMap &amp;quot;kubelet-config-1.16&amp;quot; in namespace kube-system with the configuration for the kubelets in the cluster
[upload-certs] Skipping phase. Please see --upload-certs
[mark-control-plane] Marking the node k8s-master as control-plane by adding the label &amp;quot;node-role.kubernetes.io/master=&#39;&#39;&amp;quot;
[mark-control-plane] Marking the node k8s-master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: rod570.p67pymzbil4m6u8d
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the &amp;quot;cluster-info&amp;quot; ConfigMap in the &amp;quot;kube-public&amp;quot; namespace
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your `Kubernetes`control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &amp;quot;kubectl apply -f [podnetwork].yaml&amp;quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.205.120:6443 --token rod570.p67pymzbil4m6u8d \
    --discovery-token-ca-cert-hash sha256:8f4cb9d555c78d58befeb3cfa3f7537989aa599e53e4f1bae929d8cc7afd1476

kubectl 配置
拷贝kubectl配置
$ rm -rf ~/.kube
$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config

若不配置直接使用则报无法连接错误
[vagrant@k8s-master ~]$ kubectl get pod --all-namespaces
The connection to the server localhost:8080 was refused - did you specify the right host or port?

此时使用kubectl可查看k8s容器运行情况，输出如下则为初始化成功，启动由于未配置网络插件，故coredns一直处于Pending状态
[vagrant@k8s-master ~]$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
kube-system   coredns-58cc8c89f4-c297b             0/1     Pending   0          81s
kube-system   coredns-58cc8c89f4-spzhj             0/1     Pending   0          81s
kube-system   etcd-k8s-master                      1/1     Running   0          39s
kube-system   kube-apiserver-k8s-master            1/1     Running   0          49s
kube-system   kube-controller-manager-k8s-master   1/1     Running   0          40s
kube-system   kube-proxy-xlb62                     1/1     Running   0          81s
kube-system   kube-scheduler-k8s-master            1/1     Running   0          51s

安装网络插件
网络插件有多个可选，可通过官网查看，此处选择安装flannel CNI网络插件

For flannel to work correctly, you must pass --pod-network-cidr=10.244.0.0/16 to kubeadm init.
Set /proc/sys/net/bridge/bridge-nf-call-iptables to 1 by running sysctl net.bridge.bridge-nf-call-iptables=1 to pass bridged IPv4 traffic to iptables’ chains. This is a requirement for some CNI plugins to work, for more information please see here.
Make sure that your firewall rules allow UDP ports 8285 and 8472 traffic for all hosts participating in the overlay network. see here .
Note that flannel works on amd64, arm, arm64, ppc64le and s390x under Linux. Windows (amd64) is claimed as supported in v0.11.0 but the usage is undocumented.
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml

For more information about flannel, see the CoreOS flannel repository on GitHub .

相关的网络配置已在脚本中写入，此时直接执行yml脚本即可
$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml

再次查看容器运行情况，所有容器均已运行，则master节点配置完成
[vagrant@k8s-master ~]$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
kube-system   coredns-58cc8c89f4-c297b             1/1     Running   0          5m17s
kube-system   coredns-58cc8c89f4-spzhj             1/1     Running   0          5m17s
kube-system   etcd-k8s-master                      1/1     Running   0          4m35s
kube-system   kube-apiserver-k8s-master            1/1     Running   0          4m45s
kube-system   kube-controller-manager-k8s-master   1/1     Running   0          4m36s
kube-system   kube-flannel-ds-amd64-6rchg          1/1     Running   0          3m50s
kube-system   kube-proxy-xlb62                     1/1     Running   0          5m17s
kube-system   kube-scheduler-k8s-master            1/1     Running   0          4m47s

配置worker节点
以k8s-node1为例，执行master初始化时提供的脚本即可加入k8s集群，输出如下则加入成功
[vagrant@k8s-node1 ~]$ sudo kubeadm join 192.168.205.120:6443 --token 8ry5oo.y48ksgurn103zq4h \
&amp;gt;     --discovery-token-ca-cert-hash sha256:ead07352591500c2cfe3321bf87d2e068790e16f2a7e0cc23541c864d24006d4
[preflight] Running pre-flight checks
        [WARNING IsDockerSystemdCheck]: detected &amp;quot;cgroupfs&amp;quot; as the Docker cgroup driver. The recommended driver is &amp;quot;systemd&amp;quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;
[kubelet-start] Downloading configuration for the kubelet from the &amp;quot;kubelet-config-1.16&amp;quot; ConfigMap in the kube-system namespace
[kubelet-start] Writing kubelet configuration to file &amp;quot;/var/lib/kubelet/config.yaml&amp;quot;
[kubelet-start] Writing kubelet environment file with flags to file &amp;quot;/var/lib/kubelet/kubeadm-flags.env&amp;quot;
[kubelet-start] Activating the kubelet service
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run &#39;kubectl get nodes&#39; on the control-plane to see this node join the cluster.

稍等片刻进入master节点查看容器运行情况，会发现多了几个网络容器，属于预期情况
[vagrant@k8s-master ~]$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
kube-system   coredns-58cc8c89f4-c297b             1/1     Running   0          6m28s
kube-system   coredns-58cc8c89f4-spzhj             1/1     Running   0          6m28s
kube-system   etcd-k8s-master                      1/1     Running   0          5m46s
kube-system   kube-apiserver-k8s-master            1/1     Running   0          5m56s
kube-system   kube-controller-manager-k8s-master   1/1     Running   0          5m47s
kube-system   kube-flannel-ds-amd64-6fwg5          1/1     Running   0          49s
kube-system   kube-flannel-ds-amd64-6rchg          1/1     Running   0          5m1s
kube-system   kube-flannel-ds-amd64-z4plh          1/1     Running   0          43s
kube-system   kube-proxy-cdcs4                     1/1     Running   0          49s
kube-system   kube-proxy-nlmbb                     1/1     Running   0          43s
kube-system   kube-proxy-xlb62                     1/1     Running   0          6m28s
kube-system   kube-scheduler-k8s-master            1/1     Running   0          5m58s

集群验证
在master节点中启动nginx容器测试集群情况
$ kubectl create deployment nginx --image=nginx

稍等片刻，输出如下则集群正常运行，k8s集群配置完成
[vagrant@k8s-master ~]$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
default       nginx-86c57db685-2gkxm               1/1     Running   0          58s
kube-system   coredns-58cc8c89f4-c297b             1/1     Running   0          7m46s
kube-system   coredns-58cc8c89f4-spzhj             1/1     Running   0          7m46s
kube-system   etcd-k8s-master                      1/1     Running   0          7m4s
kube-system   kube-apiserver-k8s-master            1/1     Running   0          7m14s
kube-system   kube-controller-manager-k8s-master   1/1     Running   0          7m5s
kube-system   kube-flannel-ds-amd64-6fwg5          1/1     Running   0          2m7s
kube-system   kube-flannel-ds-amd64-6rchg          1/1     Running   0          6m19s
kube-system   kube-flannel-ds-amd64-z4plh          1/1     Running   0          2m1s
kube-system   kube-proxy-cdcs4                     1/1     Running   0          2m7s
kube-system   kube-proxy-nlmbb                     1/1     Running   0          2m1s
kube-system   kube-proxy-xlb62                     1/1     Running   0          7m46s
kube-system   kube-scheduler-k8s-master            1/1     Running   0          7m16s


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://fjiayang.github.io//post/kubernetes-ji-qun-da-jian">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://fjiayang.github.io//images/avatar.png?v=1575360796156)">
        </div>
        <h1 class="id_card-title">
            F嘉阳
        </h1>
        <h2 class="id_card-description">
            温故而知新
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://fjiayang.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>