<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    SpringBoot2.x Data JPA 多数据源爬坑 | F嘉阳
</title>
<link rel="shortcut icon" href="https://fjiayang.github.io//favicon.ico?v=1579679926111">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://fjiayang.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://fjiayang.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://fjiayang.github.io/">
                <img class="avatar" src="https://fjiayang.github.io//images/avatar.png?v=1579679926111" alt="">
            </a>
            <div class="site-title">
                <h1>
                    F嘉阳
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            SpringBoot2.x Data JPA 多数据源爬坑
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2019-03-30</time>
                            
                                <a href="https://fjiayang.github.io//tag/qV7V2kVvY" class="post-tag i-tag
                            i-tag-info">
                            #Java
                        </a>
                                
                                <a href="https://fjiayang.github.io//tag/olLQ2spNZ" class="post-tag i-tag
                            i-tag-primary">
                            #SpringBoot
                        </a>
                                
                                <a href="https://fjiayang.github.io//tag/VwGnvPo1M" class="post-tag i-tag
                            i-tag-info">
                            #学习
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h2 id="jpa-官方文档">JPA 官方文档</h2>
<!-- more -->
<p><a href="https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/#jpa.java-config">官方文档</a></p>
<blockquote>
<h4 id="512-annotation-based-configuration">5.1.2. Annotation-based Configuration</h4>
<p>The Spring Data JPA repositories support can be activated not only through an XML namespace but also by using an annotation through JavaConfig, as shown in the following example:</p>
<p>Example 51. Spring Data JPA repositories using JavaConfig</p>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan(&quot;com.acme.domain&quot;);
    factory.setDataSource(dataSource());
    return factory;
  }

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    return txManager;
  }
}
</code></pre>
</blockquote>
<p>文档中说明，基于注解的配置包含三个关键Bean：</p>
<ul>
<li><code>PlatformTransactionManager</code>——事务管理</li>
<li><code>LocalContainerEntityManagerFactoryBean</code>——实体类管理</li>
<li><code>DataSource</code>——数据源</li>
</ul>
<p>同时还有一个关键注解<code>@EnableJpaRepositories</code></p>
<h2 id="springboot官方文档">SpringBoot官方文档</h2>
<p><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-a-datasource">官方文档</a></p>
<p>多数据源使用<code>@Primary</code>指明优先级</p>
<blockquote>
<p>You can even go further by leveraging what <code>DataSourceProperties</code> does for you — that is, by providing a default embedded database with a sensible username and password if no URL is provided. You can easily initialize a <code>DataSourceBuilder</code> from the state of any <code>DataSourceProperties</code> object, so you could also inject the DataSource that Spring Boot creates automatically. However, that would split your configuration into two namespaces: <code>url</code>, <code>username</code>, <code>password</code>, <code>type</code>, and <code>driver</code> on <code>spring.datasource</code> and the rest on your custom namespace (<code>app.datasource</code>). To avoid that, you can redefine a custom <code>DataSourceProperties</code> on your custom namespace, as shown in the following example:</p>
<pre><code class="language-java">@Bean
@Primary
@ConfigurationProperties(&quot;app.datasource&quot;)
public DataSourceProperties dataSourceProperties() {
	return new DataSourceProperties();
}

@Bean
@ConfigurationProperties(&quot;app.datasource.configuration&quot;)
public HikariDataSource dataSource(DataSourceProperties properties) {
	return properties.initializeDataSourceBuilder().type(HikariDataSource.class)
			.build();
}
</code></pre>
<h2 id="842-configure-two-datasources">84.2 Configure Two DataSources</h2>
<p>If you need to configure multiple data sources, you can apply the same tricks that are described in the previous section. You must, however, mark one of the <code>DataSource</code> instances as <code>@Primary</code>, because various auto-configurations down the road expect to be able to get one by type.</p>
<p>If you create your own <code>DataSource</code>, the auto-configuration backs off. In the following example, we provide the <em>exact</em> same feature set as the auto-configuration provides on the primary data source:</p>
<pre><code class="language-java">@Bean
@Primary
@ConfigurationProperties(&quot;app.datasource.first&quot;)
public DataSourceProperties firstDataSourceProperties() {
	return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties(&quot;app.datasource.first.configuration&quot;)
public HikariDataSource firstDataSource() {
	return firstDataSourceProperties().initializeDataSourceBuilder()
			.type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties(&quot;app.datasource.second&quot;)
public BasicDataSource secondDataSource() {
	return DataSourceBuilder.create().type(BasicDataSource.class).build();
}
</code></pre>
</blockquote>
<p>或者使用两个<code>EntityManagers</code>，并结合<code>@EnableJpaRepositories</code>进行配置</p>
<blockquote>
<h2 id="8410-use-two-entitymanagers">84.10 Use Two EntityManagers</h2>
<p>Even if the default <code>EntityManagerFactory</code> works fine, you need to define a new one. Otherwise, the presence of the second bean of that type switches off the default. To make it easy to do, you can use the convenient <code>EntityManagerBuilder</code> provided by Spring Boot. Alternatively, you can just the<code>LocalContainerEntityManagerFactoryBean</code> directly from Spring ORM, as shown in the following example:</p>
<pre><code class="language-java">// add two data sources configured as above

@Bean
public LocalContainerEntityManagerFactoryBean customerEntityManagerFactory(
		EntityManagerFactoryBuilder builder) {
	return builder
			.dataSource(customerDataSource())
			.packages(Customer.class)
			.persistenceUnit(&quot;customers&quot;)
			.build();
}

@Bean
public LocalContainerEntityManagerFactoryBean orderEntityManagerFactory(
		EntityManagerFactoryBuilder builder) {
	return builder
			.dataSource(orderDataSource())
			.packages(Order.class)
			.persistenceUnit(&quot;orders&quot;)
			.build();
}
</code></pre>
<p>The configuration above almost works on its own. To complete the picture, you need to configure <code>TransactionManagers</code> for the two <code>EntityManagers</code> as well. If you mark one of them as <code>@Primary</code>, it could be picked up by the default <code>JpaTransactionManager</code> in Spring Boot. The other would have to be explicitly injected into a new instance. Alternatively, you might be able to use a JTA transaction manager that spans both.</p>
<p>If you use Spring Data, you need to configure <code>@EnableJpaRepositories</code> accordingly, as shown in the following example:</p>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(basePackageClasses = Customer.class,
		entityManagerFactoryRef = &quot;customerEntityManagerFactory&quot;)
public class CustomerConfiguration {
	...
}

@Configuration
@EnableJpaRepositories(basePackageClasses = Order.class,
		entityManagerFactoryRef = &quot;orderEntityManagerFactory&quot;)
public class OrderConfiguration {
	...
}
</code></pre>
</blockquote>
<h2 id="源码分析">源码分析</h2>
<p>自动装配类中声明了配置Bean和条件装配顺序</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.data.jpa;

/**
 * {@link EnableAutoConfiguration Auto-configuration} for Spring Data's JPA Repositories.
 * &lt;p&gt;
 * Activates when there is a bean of type {@link javax.sql.DataSource} configured in the
 * context, the Spring Data JPA
 * {@link org.springframework.data.jpa.repository.JpaRepository} type is on the classpath,
 * and there is no other, existing
 * {@link org.springframework.data.jpa.repository.JpaRepository} configured.
 * &lt;p&gt;
 * Once in effect, the auto-configuration is the equivalent of enabling JPA repositories
 * using the {@link org.springframework.data.jpa.repository.config.EnableJpaRepositories}
 * annotation.
 * &lt;p&gt;
 * This configuration class will activate &lt;em&gt;after&lt;/em&gt; the Hibernate auto-configuration.
 *
 * @author Phillip Webb
 * @author Josh Long
 * @see EnableJpaRepositories
 */
@Configuration
@ConditionalOnBean(DataSource.class)
@ConditionalOnClass(JpaRepository.class)
@ConditionalOnMissingBean({ JpaRepositoryFactoryBean.class,
		JpaRepositoryConfigExtension.class })
@ConditionalOnProperty(prefix = &quot;spring.data.jpa.repositories&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
@Import(JpaRepositoriesAutoConfigureRegistrar.class)
@AutoConfigureAfter({ HibernateJpaAutoConfiguration.class,
		TaskExecutionAutoConfiguration.class })
public class JpaRepositoriesAutoConfiguration {

	@Bean
	@Conditional(BootstrapExecutorCondition.class)
	public EntityManagerFactoryBuilderCustomizer entityManagerFactoryBootstrapExecutorCustomizer(
			Map&lt;String, AsyncTaskExecutor&gt; taskExecutors) {
		return (builder) -&gt; {
			AsyncTaskExecutor bootstrapExecutor = determineBootstrapExecutor(
					taskExecutors);
			if (bootstrapExecutor != null) {
				builder.setBootstrapExecutor(bootstrapExecutor);
			}
		};
	}

	private AsyncTaskExecutor determineBootstrapExecutor(
			Map&lt;String, AsyncTaskExecutor&gt; taskExecutors) {
		if (taskExecutors.size() == 1) {
			return taskExecutors.values().iterator().next();
		}
		return taskExecutors
				.get(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME);
	}

	private static final class BootstrapExecutorCondition extends AnyNestedCondition {

		BootstrapExecutorCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}

		@ConditionalOnProperty(prefix = &quot;spring.data.jpa.repositories&quot;, name = &quot;bootstrap-mode&quot;, havingValue = &quot;deferred&quot;, matchIfMissing = false)
		static class DeferredBootstrapMode {

		}

		@ConditionalOnProperty(prefix = &quot;spring.data.jpa.repositories&quot;, name = &quot;bootstrap-mode&quot;, havingValue = &quot;lazy&quot;, matchIfMissing = false)
		static class LazyBootstrapMode {

		}

	}
}
</code></pre>
<p>引入的配置类中声明了<code>EnableJpaRepositories</code>注解</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.data.jpa;

class JpaRepositoriesAutoConfigureRegistrar
		extends AbstractRepositoryConfigurationSourceSupport {

	private BootstrapMode bootstrapMode = null;

	@Override
	protected Class&lt;? extends Annotation&gt; getAnnotation() {
		return EnableJpaRepositories.class;
	}

	@Override
	protected Class&lt;?&gt; getConfiguration() {
		return EnableJpaRepositoriesConfiguration.class;
	}

	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new JpaRepositoryConfigExtension();
	}

	@Override
	protected BootstrapMode getBootstrapMode() {
		return (this.bootstrapMode == null) ? super.getBootstrapMode()
				: this.bootstrapMode;
	}

	@Override
	public void setEnvironment(Environment environment) {
		super.setEnvironment(environment);
		configureBootstrapMode(environment);
	}

	private void configureBootstrapMode(Environment environment) {
		String property = environment
				.getProperty(&quot;spring.data.jpa.repositories.bootstrap-mode&quot;);
		if (StringUtils.hasText(property)) {
			this.bootstrapMode = BootstrapMode
					.valueOf(property.toUpperCase(Locale.ENGLISH));
		}
	}
    
	@EnableJpaRepositories
	private static class EnableJpaRepositoriesConfiguration {}
}
</code></pre>
<p><code>EnableJpaRepositories</code>注解定义</p>
<pre><code class="language-java">package org.springframework.data.jpa.repository.config;

/**
 * Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data
 * repositories by default.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JpaRepositoriesRegistrar.class)
public @interface EnableJpaRepositories {

	String[] value() default {};

	String[] basePackages() default {};

	Class&lt;?&gt;[] basePackageClasses() default {};

	Filter[] includeFilters() default {};

	Filter[] excludeFilters() default {};

	String repositoryImplementationPostfix() default &quot;Impl&quot;;

	String namedQueriesLocation() default &quot;&quot;;

	Key queryLookupStrategy() default Key.CREATE_IF_NOT_FOUND;

	Class&lt;?&gt; repositoryFactoryBeanClass() default JpaRepositoryFactoryBean.class;

	Class&lt;?&gt; repositoryBaseClass() default DefaultRepositoryBaseClass.class;

	/**
	 * 实体管理工厂
	 * @return
	 */
	String entityManagerFactoryRef() default &quot;entityManagerFactory&quot;;

	/**
	 * 事务管理
	 * @return
	 */
	String transactionManagerRef() default &quot;transactionManager&quot;;

	boolean considerNestedRepositories() default false;

	boolean enableDefaultTransactions() default true;

	/**
	 * Configures when the repositories are initialized in the bootstrap lifecycle. {@link BootstrapMode#DEFAULT}
	 * (default) means eager initialization except all repository interfaces annotated with {@link Lazy},
	 * {@link BootstrapMode#LAZY} means lazy by default including injection of lazy-initialization proxies into client
	 * beans so that those can be instantiated but will only trigger the initialization upon first repository usage (i.e a
	 * method invocation on it). This means repositories can still be uninitialized when the application context has
	 * completed its bootstrap. {@link BootstrapMode#DEFERRED} is fundamentally the same as {@link BootstrapMode#LAZY},
	 * but triggers repository initialization when the application context finishes its bootstrap.
	 * 
	 * @return
	 * @since 2.1
	 */
	BootstrapMode bootstrapMode() default BootstrapMode.DEFAULT;
}
</code></pre>
<p>查找关键Bean的注册时机</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.orm.jpa;

@Configuration
@ConditionalOnClass({ LocalContainerEntityManagerFactoryBean.class, EntityManager.class })
@Conditional(HibernateEntityManagerCondition.class)
@EnableConfigurationProperties(JpaProperties.class)
@AutoConfigureAfter({ DataSourceAutoConfiguration.class })
@Import(HibernateJpaConfiguration.class)
public class HibernateJpaAutoConfiguration {}
</code></pre>
<p>进入配置Bean</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.orm.jpa;

@Configuration
@EnableConfigurationProperties(HibernateProperties.class)
@ConditionalOnSingleCandidate(DataSource.class)
class HibernateJpaConfiguration extends JpaBaseConfiguration {}
</code></pre>
<p>在其父类<code>JpaBaseConfiguration</code>中声明了装配时机和条件</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.orm.jpa;

/**
 * 该类在2.0版本进行了重构
 * @since 2.0.0
 */
@Configuration
@EnableConfigurationProperties(JpaProperties.class)
@Import(DataSourceInitializedPublisher.Registrar.class)
public abstract class JpaBaseConfiguration implements BeanFactoryAware {
    
    @Bean
	@ConditionalOnMissingBean
	public PlatformTransactionManager transactionManager() {
		JpaTransactionManager transactionManager = new JpaTransactionManager();
		if (this.transactionManagerCustomizers != null) {
            // 默认使用方法名称
			this.transactionManagerCustomizers.customize(transactionManager);
		}
		return transactionManager;
	}

	@Bean
	@ConditionalOnMissingBean
	public JpaVendorAdapter jpaVendorAdapter() {
		AbstractJpaVendorAdapter adapter = createJpaVendorAdapter();
		adapter.setShowSql(this.properties.isShowSql());
		adapter.setDatabase(this.properties.determineDatabase(this.dataSource));
		adapter.setDatabasePlatform(this.properties.getDatabasePlatform());
		adapter.setGenerateDdl(this.properties.isGenerateDdl());
		return adapter;
	}

	@Bean
	@ConditionalOnMissingBean
	public EntityManagerFactoryBuilder entityManagerFactoryBuilder(
			JpaVendorAdapter jpaVendorAdapter,
			ObjectProvider&lt;PersistenceUnitManager&gt; persistenceUnitManager,
			ObjectProvider&lt;EntityManagerFactoryBuilderCustomizer&gt; customizers) {
		EntityManagerFactoryBuilder builder = new EntityManagerFactoryBuilder(
				jpaVendorAdapter, this.properties.getProperties(),
				persistenceUnitManager.getIfAvailable());
		customizers.orderedStream()
				.forEach((customizer) -&gt; customizer.customize(builder));
		return builder;
	}

	@Bean
	@Primary
	@ConditionalOnMissingBean({ LocalContainerEntityManagerFactoryBean.class,
			EntityManagerFactory.class })
	public LocalContainerEntityManagerFactoryBean entityManagerFactory(
			EntityManagerFactoryBuilder factoryBuilder) {
		Map&lt;String, Object&gt; vendorProperties = getVendorProperties();
		customizeVendorProperties(vendorProperties);
		return factoryBuilder.dataSource(this.dataSource).packages(getPackagesToScan())
				.properties(vendorProperties).mappingResources(getMappingResources())
				.jta(isJta()).build();
	}
}
</code></pre>
<h2 id="测试">测试</h2>
<p>爬完文档和源码，对需要配置Bean有了基本了解，新建工程进行多数据源测试</p>
<p>以当前最新版本SpringBoot进行测试</p>
<h3 id="maven">maven</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;top.fjy8018&lt;/groupId&gt;
    &lt;artifactId&gt;jpadatasource&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;jpadatasource&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="实体类">实体类</h3>
<p>通过包路径区分主库和备份库</p>
<p>主库实体类</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.entity.primary;

import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.Id;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:11
 */
@Data
@Entity
public class Product {

    @Id
    private Integer id;

    private String name;

    private Integer price;
}
</code></pre>
<p>备份库实体类</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.entity.backup;

import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.Id;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:36
 */
@Data
@Entity(name = &quot;tb_order&quot;)
public class Order {

    @Id
    private Integer id;

    private String orderName;

    private Integer price;
}
</code></pre>
<h4 id="坑一表名关键字冲突">坑一：表名关键字冲突</h4>
<p>若此处不指定表名为<code>tb_order</code>则会与MySQL关键字冲突导致建表失败</p>
<p>报错：</p>
<pre><code>org.hibernate.tool.schema.spi.CommandAcceptanceException: Error executing DDL &quot;
    create table Order (
       id integer not null,
        orderName varchar(255),
        price integer,
        primary key (id)
    ) engine=InnoDB&quot; via JDBC Statement
    ...
</code></pre>
<h3 id="dao">DAO</h3>
<pre><code class="language-java">package top.fjy8018.jpadatasource.repository.backup;

import org.springframework.data.jpa.repository.JpaRepository;
import top.fjy8018.jpadatasource.entity.backup.Order;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:12
 */
public interface OrderRepository extends JpaRepository&lt;Order, Integer&gt; {
}
</code></pre>
<pre><code class="language-java">package top.fjy8018.jpadatasource.repository.primary;

import org.springframework.data.jpa.repository.JpaRepository;
import top.fjy8018.jpadatasource.entity.primary.Product;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:12
 */
public interface ProductRepository extends JpaRepository&lt;Product, Integer&gt; {
}
</code></pre>
<h3 id="配置bean">配置Bean</h3>
<blockquote>
<p>官方配置样例：</p>
<p>Both data sources are also bound for advanced customizations. For instance, you could configure them as follows:</p>
<pre><code class="language-properties">app.datasource.first.url=jdbc:mysql://localhost/first
app.datasource.first.username=dbuser
app.datasource.first.password=dbpass
app.datasource.first.configuration.maximum-pool-size=30

app.datasource.second.url=jdbc:mysql://localhost/second
app.datasource.second.username=dbuser
app.datasource.second.password=dbpass
app.datasource.second.max-total=30
</code></pre>
<p>You can apply the same concept to the secondary <code>DataSource</code> as well, as shown in the following example:</p>
<pre><code class="language-java">@Bean
@Primary
@ConfigurationProperties(&quot;app.datasource.first&quot;)
public DataSourceProperties firstDataSourceProperties() {
	return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties(&quot;app.datasource.first.configuration&quot;)
public HikariDataSource firstDataSource() {
	return firstDataSourceProperties().initializeDataSourceBuilder()
			.type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties(&quot;app.datasource.second&quot;)
public DataSourceProperties secondDataSourceProperties() {
	return new DataSourceProperties();
}

@Bean
@ConfigurationProperties(&quot;app.datasource.second.configuration&quot;)
public BasicDataSource secondDataSource() {
	return secondDataSourceProperties().initializeDataSourceBuilder()
			.type(BasicDataSource.class).build();
}
</code></pre>
<p>The preceding example configures two data sources on custom namespaces with the same logic as Spring Boot would use in auto-configuration. Note that each <code>configuration</code> sub namespace provides advanced settings based on the chosen implementation.</p>
</blockquote>
<p>参照编写配置文件，<strong>此处注意SpringBoot 2.x的驱动变化</strong></p>
<h4 id="坑二mysql驱动类名变化">坑二：mysql驱动类名变化</h4>
<pre><code class="language-yaml">spring:
  datasource:
    first:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: financial_adminer
      password: financial_adminer_pass
      url: jdbc:mysql://localhost/jpa_test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
      configuration:
        maximum-pool-size: 30
    second:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: financial_adminer
      password: financial_adminer_pass
      url: jdbc:mysql://localhost/jpa_test_bak?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
      configuration:
        maximum-pool-size: 20

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    database-platform: org.hibernate.dialect.MySQL55Dialect
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
</code></pre>
<p>配置类</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:24
 */
@Configuration
public class DataAccessConfig {
    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first&quot;)
    public DataSourceProperties firstDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first.configuration&quot;)
    public HikariDataSource firstDataSource() {
        return firstDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second&quot;)
    public DataSourceProperties secondDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second.configuration&quot;)
    public HikariDataSource secondDataSource() {
        return secondDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }
}
</code></pre>
<p>配置完成后发现只在主库自动建表，备份库无变化，属于预期情况，因为目前仅配置了三个必须Bean的其中一个</p>
<p>继续配置实体管理和事务管理Bean</p>
<p>官方文档样例</p>
<blockquote>
<h2 id="8410-use-two-entitymanagers-2">84.10 Use Two EntityManagers</h2>
<p>Even if the default <code>EntityManagerFactory</code> works fine, you need to define a new one. Otherwise, the presence of the second bean of that type switches off the default. To make it easy to do, you can use the convenient <code>EntityManagerBuilder</code> provided by Spring Boot. Alternatively, you can just the<code>LocalContainerEntityManagerFactoryBean</code> directly from Spring ORM, as shown in the following example:</p>
<pre><code class="language-java">// add two data sources configured as above

@Bean
public LocalContainerEntityManagerFactoryBean customerEntityManagerFactory(
		EntityManagerFactoryBuilder builder) {
	return builder
			.dataSource(customerDataSource())
			.packages(Customer.class)
			.persistenceUnit(&quot;customers&quot;)
			.build();
}

@Bean
public LocalContainerEntityManagerFactoryBean orderEntityManagerFactory(
		EntityManagerFactoryBuilder builder) {
	return builder
			.dataSource(orderDataSource())
			.packages(Order.class)
			.persistenceUnit(&quot;orders&quot;)
			.build();
}
</code></pre>
<p>The configuration above almost works on its own. To complete the picture, you need to configure <code>TransactionManagers</code> for the two <code>EntityManagers</code> as well. If you mark one of them as <code>@Primary</code>, it could be picked up by the default <code>JpaTransactionManager</code> in Spring Boot. The other would have to be explicitly injected into a new instance. Alternatively, you might be able to use a JTA transaction manager that spans both.</p>
<p>If you use Spring Data, you need to configure <code>@EnableJpaRepositories</code> accordingly, as shown in the following example:</p>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(basePackageClasses = Customer.class,
		entityManagerFactoryRef = &quot;customerEntityManagerFactory&quot;)
public class CustomerConfiguration {
	...
}

@Configuration
@EnableJpaRepositories(basePackageClasses = Order.class,
		entityManagerFactoryRef = &quot;orderEntityManagerFactory&quot;)
public class OrderConfiguration {
	...
}
</code></pre>
</blockquote>
<p>工程配置</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import top.fjy8018.jpadatasource.entity.backup.Order;
import top.fjy8018.jpadatasource.entity.primary.Product;
import top.fjy8018.jpadatasource.repository.backup.OrderRepository;
import top.fjy8018.jpadatasource.repository.primary.ProductRepository;

import javax.sql.DataSource;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:24
 */
@Configuration
public class DataAccessConfig {
    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first&quot;)
    public DataSourceProperties firstDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first.configuration&quot;)
    public HikariDataSource firstDataSource() {
        return firstDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second&quot;)
    public DataSourceProperties secondDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second.configuration&quot;)
    public HikariDataSource secondDataSource() {
        return secondDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean firstEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;firstDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                .packages(Product.class)
                .persistenceUnit(&quot;first&quot;)
                .build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;secondDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                .packages(Order.class)
                .persistenceUnit(&quot;second&quot;)
                .build();
    }

    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier(&quot;firstEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @Bean
    public PlatformTransactionManager backupTransactionManager(
            @Qualifier(&quot;secondEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @EnableJpaRepositories(basePackageClasses = ProductRepository.class,
            entityManagerFactoryRef = &quot;firstEntityManagerFactory&quot;)
    @Primary
    public class PrimaryConfiguration {
    }

    @EnableJpaRepositories(basePackageClasses = OrderRepository.class,
            entityManagerFactoryRef = &quot;secondEntityManagerFactory&quot;)
    public class secondConfiguration {
    }
}
</code></pre>
<h4 id="坑三官方文档样例有误">坑三：官方文档样例有误</h4>
<p>此时配置直接启动会报错</p>
<pre><code>Method requestMappingHandlerMapping in org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration required a single bean, but 2 were found:
	- firstEntityManagerFactory: defined by method 'firstEntityManagerFactory' in class path resource [top/fjy8018/jpadatasource/config/DataAccessConfig.class]
	- secondEntityManagerFactory: defined by method 'secondEntityManagerFactory' in class path resource [top/fjy8018/jpadatasource/config/DataAccessConfig.class]


Action:

Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed

</code></pre>
<p>意思是自动装配时发现两个类型一致的Bean，主要指定优先级，而官方文档对此处可能出现的问题并未提示</p>
<p>指定<code>firstEntityManagerFactory</code>为优先Bean，同时文档样例创建了事务管理器但未配置到<code>@EnableJpaRepositories</code>注解中，此处也一并配置</p>
<p>最终配置类如下</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import top.fjy8018.jpadatasource.entity.backup.Order;
import top.fjy8018.jpadatasource.entity.primary.Product;
import top.fjy8018.jpadatasource.repository.backup.OrderRepository;
import top.fjy8018.jpadatasource.repository.primary.ProductRepository;

import javax.sql.DataSource;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:24
 */
@Configuration
public class DataAccessConfig {
    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first&quot;)
    public DataSourceProperties firstDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first.configuration&quot;)
    public HikariDataSource firstDataSource() {
        return firstDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second&quot;)
    public DataSourceProperties secondDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second.configuration&quot;)
    public HikariDataSource secondDataSource() {
        return secondDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean firstEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;firstDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                .packages(Product.class)
                .persistenceUnit(&quot;first&quot;)
                .build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;secondDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                .packages(Order.class)
                .persistenceUnit(&quot;second&quot;)
                .build();
    }

    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier(&quot;firstEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @Bean
    public PlatformTransactionManager backupTransactionManager(
            @Qualifier(&quot;secondEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @EnableJpaRepositories(basePackageClasses = ProductRepository.class,
            entityManagerFactoryRef = &quot;firstEntityManagerFactory&quot;, transactionManagerRef = &quot;primaryTransactionManager&quot;)
    @Primary
    public class PrimaryConfiguration {
    }

    @EnableJpaRepositories(basePackageClasses = OrderRepository.class,
            entityManagerFactoryRef = &quot;secondEntityManagerFactory&quot;, transactionManagerRef = &quot;backupTransactionManager&quot;)
    public class secondConfiguration {
    }
}
</code></pre>
<h4 id="坑四jpa不会自动建表">坑四：JPA不会自动建表</h4>
<p>配置完成后启动</p>
<figure data-type="image" tabindex="1"><a href="https://i.loli.net/2019/03/30/5c9ed56325a01.png"><img src="https://i.loli.net/2019/03/30/5c9ed56325a01.png" alt="Snipaste_2019-03-30_10-32-35.png"></a></figure>
<p>发现日志中建表SQL没有输出，同时查看数据库，确认表未创建</p>
<p>但官方文档对多数据源的配置说明已经结束，令人疑惑</p>
<p>自动建表语句没生成猜想可能由于与ddl相关的属性未配置导致</p>
<p>进入配置文件查看ddl配置，发现默认为false</p>
<figure data-type="image" tabindex="2"><a href="https://i.loli.net/2019/03/30/5c9ed66fb8481.png"><img src="https://i.loli.net/2019/03/30/5c9ed66fb8481.png" alt="1553913435794.png"></a></figure>
<p>将其配置为true后总配置文件如下</p>
<pre><code class="language-yaml">spring:
  datasource:
    first:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: financial_adminer
      password: financial_adminer_pass
      url: jdbc:mysql://120.79.226.26/jpa_test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
      configuration:
        maximum-pool-size: 30
    second:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: financial_adminer
      password: financial_adminer_pass
      url: jdbc:mysql://120.79.226.26/jpa_test_bak?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
      configuration:
        maximum-pool-size: 20

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    database-platform: org.hibernate.dialect.MySQL55Dialect
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
    generate-ddl: true
</code></pre>
<p>启动工程发现自动建表生效</p>
<figure data-type="image" tabindex="3"><a href="https://i.loli.net/2019/03/30/5c9ed6dba2070.png"><img src="https://i.loli.net/2019/03/30/5c9ed6dba2070.png" alt="1553913556405.png"></a></figure>
<p>查看数据库情况，与预期一致，主库只包含主库的表，备份库只包含备份库的表，多数据配置完成</p>
<figure data-type="image" tabindex="4"><a href="https://i.loli.net/2019/03/30/5c9ed727864e4.png"><img src="https://i.loli.net/2019/03/30/5c9ed727864e4.png" alt="1553913636212.png"></a></figure>
<h4 id="坑五hibernate默认配置被覆盖">坑五：hibernate默认配置被覆盖</h4>
<p>若在单数据源配置下应当无需配置该项，同时发现本应该默认将驼峰属性名映射为<code>_</code>拼接名称策略也失效，说明自定义配置源时覆盖了默认配置或者导致默认配置失效</p>
<figure data-type="image" tabindex="5"><a href="https://i.loli.net/2019/03/30/5c9f4fca79187.png"><img src="https://i.loli.net/2019/03/30/5c9f4fca79187.png" alt="1553944509394.png"></a></figure>
<p>查询源码分析原因，发现<code>hibernate</code>相关配置均在<code>HibernateProperties</code>配置类中</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.orm.jpa;

/**
 * Configuration properties for Hibernate.
 *
 * @author Stephane Nicoll
 * @since 2.1.0
 * @see JpaProperties
 */
@ConfigurationProperties(&quot;spring.jpa.hibernate&quot;)
public class HibernateProperties {}
</code></pre>
<p>而该类在<code>HibernateJpaConfiguration</code>中进行注入，但配置类中进行了条件装配注解<code>@ConditionalOnSingleCandidate</code>标注，导致在多数据源情况下不满足该配置，类没有被装配到Spring Bean中</p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure.orm.jpa;

/**
 * {@link JpaBaseConfiguration} implementation for Hibernate.
 * @since 2.0.0
 */
@Configuration
@EnableConfigurationProperties(HibernateProperties.class)
@ConditionalOnSingleCandidate(DataSource.class)
class HibernateJpaConfiguration extends JpaBaseConfiguration {

	private final HibernateProperties hibernateProperties;

	HibernateJpaConfiguration(DataSource dataSource, JpaProperties jpaProperties,
			ConfigurableListableBeanFactory beanFactory,
			ObjectProvider&lt;JtaTransactionManager&gt; jtaTransactionManager,
			ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers,
			HibernateProperties hibernateProperties,
			ObjectProvider&lt;Collection&lt;DataSourcePoolMetadataProvider&gt;&gt; metadataProviders,
			ObjectProvider&lt;SchemaManagementProvider&gt; providers,
			ObjectProvider&lt;PhysicalNamingStrategy&gt; physicalNamingStrategy,
			ObjectProvider&lt;ImplicitNamingStrategy&gt; implicitNamingStrategy,
			ObjectProvider&lt;HibernatePropertiesCustomizer&gt; hibernatePropertiesCustomizers) {
		super(dataSource, jpaProperties, jtaTransactionManager,
				transactionManagerCustomizers);
		this.hibernateProperties = hibernateProperties;
		this.defaultDdlAutoProvider = new HibernateDefaultDdlAutoProvider(providers);
		this.poolMetadataProvider = new CompositeDataSourcePoolMetadataProvider(
				metadataProviders.getIfAvailable());
		this.hibernatePropertiesCustomizers = determineHibernatePropertiesCustomizers(
				physicalNamingStrategy.getIfAvailable(),
				implicitNamingStrategy.getIfAvailable(), beanFactory,
				hibernatePropertiesCustomizers.orderedStream()
						.collect(Collectors.toList()));
	}
    ...
}
</code></pre>
<p>解决方法就只能自己工程内实现该类的配置，<strong>注意，Spring 2.x版本自动装配变化较大，当前配置基于最新版2.1.3有效，并不代表对后续版本一定兼容</strong></p>
<p>工程配置</p>
<pre><code class="language-java">package top.fjy8018.jpadatasource.config;

import com.zaxxer.hikari.HikariDataSource;
import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
import org.hibernate.cfg.AvailableSettings;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;
import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.EmbeddedDatabaseConnection;
import org.springframework.boot.jdbc.SchemaManagement;
import org.springframework.boot.jdbc.SchemaManagementProvider;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.util.ClassUtils;
import top.fjy8018.jpadatasource.entity.backup.Order;
import top.fjy8018.jpadatasource.entity.primary.Product;
import top.fjy8018.jpadatasource.repository.backup.OrderRepository;
import top.fjy8018.jpadatasource.repository.primary.ProductRepository;

import javax.sql.DataSource;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

/**
 * @author F嘉阳
 * @date 2019-03-30 9:24
 */
@Configuration
public class DataAccessConfig {

    private final ObjectProvider&lt;SchemaManagementProvider&gt; providers;

    private final HibernateProperties hibernateProperties;

    private final JpaProperties properties;

    private final ObjectProvider&lt;PhysicalNamingStrategy&gt; physicalNamingStrategy;

    private final ObjectProvider&lt;ImplicitNamingStrategy&gt; implicitNamingStrategy;

    private final ConfigurableListableBeanFactory beanFactory;

    private final ObjectProvider&lt;HibernatePropertiesCustomizer&gt; hibernatePropertiesCustomizers;

    @Autowired
    public DataAccessConfig(ObjectProvider&lt;SchemaManagementProvider&gt; providers, HibernateProperties hibernateProperties, JpaProperties properties, ObjectProvider&lt;PhysicalNamingStrategy&gt; physicalNamingStrategy, ObjectProvider&lt;ImplicitNamingStrategy&gt; implicitNamingStrategy, ConfigurableListableBeanFactory beanFactory, ObjectProvider&lt;HibernatePropertiesCustomizer&gt; hibernatePropertiesCustomizers) {
        this.providers = providers;
        this.hibernateProperties = hibernateProperties;
        this.properties = properties;
        this.physicalNamingStrategy = physicalNamingStrategy;
        this.implicitNamingStrategy = implicitNamingStrategy;
        this.beanFactory = beanFactory;
        this.hibernatePropertiesCustomizers = hibernatePropertiesCustomizers;
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first&quot;)
    public DataSourceProperties firstDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.first.configuration&quot;)
    public HikariDataSource firstDataSource() {
        return firstDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second&quot;)
    public DataSourceProperties secondDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.second.configuration&quot;)
    public HikariDataSource secondDataSource() {
        return secondDataSourceProperties().initializeDataSourceBuilder()
                .type(HikariDataSource.class).build();
    }

    @Bean
    @Primary
    public LocalContainerEntityManagerFactoryBean firstEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;firstDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                // 加入规约配置
                .properties(getVendorProperties(dataSource))
                .packages(Product.class)
                .persistenceUnit(&quot;first&quot;)
                .build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondEntityManagerFactory(
            EntityManagerFactoryBuilder builder, @Qualifier(&quot;secondDataSource&quot;) DataSource dataSource) {
        return builder
                .dataSource(dataSource)
                .properties(getVendorProperties(dataSource))
                .packages(Order.class)
                .persistenceUnit(&quot;second&quot;)
                .build();
    }

    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier(&quot;firstEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @Bean
    public PlatformTransactionManager backupTransactionManager(
            @Qualifier(&quot;secondEntityManagerFactory&quot;) LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory.getObject());
    }

    @EnableJpaRepositories(basePackageClasses = ProductRepository.class,
            entityManagerFactoryRef = &quot;firstEntityManagerFactory&quot;, transactionManagerRef = &quot;primaryTransactionManager&quot;)
    @Primary
    public class PrimaryConfiguration {
    }

    @EnableJpaRepositories(basePackageClasses = OrderRepository.class,
            entityManagerFactoryRef = &quot;secondEntityManagerFactory&quot;, transactionManagerRef = &quot;backupTransactionManager&quot;)
    public class secondConfiguration {
    }

    /**
     * 获取配置文件信息
     *
     * @param dataSource
     * @return
     */
    private Map&lt;String, Object&gt; getVendorProperties(DataSource dataSource) {
        List&lt;HibernatePropertiesCustomizer&gt; hibernatePropertiesCustomizers = determineHibernatePropertiesCustomizers(
                physicalNamingStrategy.getIfAvailable(),
                implicitNamingStrategy.getIfAvailable(), beanFactory,
                this.hibernatePropertiesCustomizers.orderedStream()
                        .collect(Collectors.toList()));
        Supplier&lt;String&gt; defaultDdlMode = () -&gt; new HibernateDefaultDdlAutoProvider(providers)
                .getDefaultDdlAuto(dataSource);
        return new LinkedHashMap&lt;&gt;(this.hibernateProperties.determineHibernateProperties(
                properties.getProperties(),
                new HibernateSettings().ddlAuto(defaultDdlMode)
                        .hibernatePropertiesCustomizers(
                                hibernatePropertiesCustomizers)));
    }

    /**
     * 命名策略自动判断
     *
     * @param physicalNamingStrategy
     * @param implicitNamingStrategy
     * @param beanFactory
     * @param hibernatePropertiesCustomizers
     * @return
     */
    private List&lt;HibernatePropertiesCustomizer&gt; determineHibernatePropertiesCustomizers(
            PhysicalNamingStrategy physicalNamingStrategy,
            ImplicitNamingStrategy implicitNamingStrategy,
            ConfigurableListableBeanFactory beanFactory,
            List&lt;HibernatePropertiesCustomizer&gt; hibernatePropertiesCustomizers) {
        List&lt;HibernatePropertiesCustomizer&gt; customizers = new ArrayList&lt;&gt;();
        if (ClassUtils.isPresent(
                &quot;org.hibernate.resource.beans.container.spi.BeanContainer&quot;,
                getClass().getClassLoader())) {
            customizers
                    .add((properties) -&gt; properties.put(AvailableSettings.BEAN_CONTAINER,
                            new SpringBeanContainer(beanFactory)));
        }
        if (physicalNamingStrategy != null || implicitNamingStrategy != null) {
            customizers.add(new NamingStrategiesHibernatePropertiesCustomizer(
                    physicalNamingStrategy, implicitNamingStrategy));
        }
        customizers.addAll(hibernatePropertiesCustomizers);
        return customizers;
    }

    /**
     * 自动进行建表操作
     */
    class HibernateDefaultDdlAutoProvider implements SchemaManagementProvider {

        private final Iterable&lt;SchemaManagementProvider&gt; providers;

        HibernateDefaultDdlAutoProvider(Iterable&lt;SchemaManagementProvider&gt; providers) {
            this.providers = providers;
        }

        public String getDefaultDdlAuto(DataSource dataSource) {
            if (!EmbeddedDatabaseConnection.isEmbedded(dataSource)) {
                return &quot;none&quot;;
            }
            SchemaManagement schemaManagement = getSchemaManagement(dataSource);
            if (SchemaManagement.MANAGED.equals(schemaManagement)) {
                return &quot;none&quot;;
            }
            return &quot;create-drop&quot;;

        }

        @Override
        public SchemaManagement getSchemaManagement(DataSource dataSource) {
            return StreamSupport.stream(this.providers.spliterator(), false)
                    .map((provider) -&gt; provider.getSchemaManagement(dataSource))
                    .filter(SchemaManagement.MANAGED::equals).findFirst()
                    .orElse(SchemaManagement.UNMANAGED);
        }

    }

    private static class NamingStrategiesHibernatePropertiesCustomizer
            implements HibernatePropertiesCustomizer {

        private final PhysicalNamingStrategy physicalNamingStrategy;

        private final ImplicitNamingStrategy implicitNamingStrategy;

        NamingStrategiesHibernatePropertiesCustomizer(
                PhysicalNamingStrategy physicalNamingStrategy,
                ImplicitNamingStrategy implicitNamingStrategy) {
            this.physicalNamingStrategy = physicalNamingStrategy;
            this.implicitNamingStrategy = implicitNamingStrategy;
        }

        /**
         * 数据库命名映射策略
         *
         * @param hibernateProperties the JPA vendor properties to customize
         */
        @Override
        public void customize(Map&lt;String, Object&gt; hibernateProperties) {
            if (this.physicalNamingStrategy != null) {
                hibernateProperties.put(&quot;hibernate.physical_naming_strategy&quot;,
                        this.physicalNamingStrategy);
            }
            if (this.implicitNamingStrategy != null) {
                hibernateProperties.put(&quot;hibernate.implicit_naming_strategy&quot;,
                        this.implicitNamingStrategy);
            }
        }
    }
}
</code></pre>
<p>配置Bean完成后则规约配置会生效，便<strong>无需</strong>在配置文件显示配置DDL语句执行开关</p>
<p>启动日志也可看出结果符合预期</p>
<figure data-type="image" tabindex="6"><a href="https://i.loli.net/2019/03/30/5c9f50b8df2ea.png"><img src="https://i.loli.net/2019/03/30/5c9f50b8df2ea.png" alt="1553944717550.png"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://i.loli.net/2019/03/30/5c9f50b8d148c.png"><img src="https://i.loli.net/2019/03/30/5c9f50b8d148c.png" alt="1553944734003.png"></a></figure>
<h2 id="总结">总结</h2>
<p>由此发现，在SpringBoot版本迁移过程中不一定互相兼容，同时官方文档尽管全面，但随着版本变化文档也有不准确情况。而如果完全依靠爬源码复制源码配置也是无法实现最简单化的配置，需要结合文档、源码、日志逐一分析</p>
<p>工程源码已开放，注意配置自己的数据库连接地址，工程内的连接地址已经失效</p>
<p><a href="https://github.com/FJiayang/SpringBoot-Two-DataSources-Demo">GitHub源码</a></p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://fjiayang.github.io//post/leetcode-shua-ti-ji-lu">
                                <h3 class="post-title">
                                    LeetCode刷题记录
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#jpa-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">JPA 官方文档</a><br>
*
<ul>
<li><a href="#512-annotation-based-configuration">5.1.2. Annotation-based Configuration</a></li>
</ul>
</li>
<li><a href="#springboot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">SpringBoot官方文档</a></li>
<li><a href="#842-configure-two-datasources">84.2 Configure Two DataSources</a></li>
<li><a href="#8410-use-two-entitymanagers">84.10 Use Two EntityManagers</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a>
<ul>
<li><a href="#maven">maven</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB">实体类</a>
<ul>
<li><a href="#%E5%9D%91%E4%B8%80%E8%A1%A8%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%B2%E7%AA%81">坑一：表名关键字冲突</a></li>
</ul>
</li>
<li><a href="#dao">DAO</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEbean">配置Bean</a>
<ul>
<li><a href="#%E5%9D%91%E4%BA%8Cmysql%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%90%8D%E5%8F%98%E5%8C%96">坑二：mysql驱动类名变化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8410-use-two-entitymanagers-2">84.10 Use Two EntityManagers</a><br>
*
<ul>
<li><a href="#%E5%9D%91%E4%B8%89%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%A0%B7%E4%BE%8B%E6%9C%89%E8%AF%AF">坑三：官方文档样例有误</a></li>
<li><a href="#%E5%9D%91%E5%9B%9Bjpa%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%BB%BA%E8%A1%A8">坑四：JPA不会自动建表</a></li>
<li><a href="#%E5%9D%91%E4%BA%94hibernate%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E8%A2%AB%E8%A6%86%E7%9B%96">坑五：hibernate默认配置被覆盖</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a href="https://blog.fjy8018.top/" target="_blank">F嘉阳 博客</a> | 
  <a class="rss" href="https://fjiayang.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>